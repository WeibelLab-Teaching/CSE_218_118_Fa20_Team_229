"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Schema = void 0;
var spec_1 = require("./spec");
var annotations_1 = require("./annotations");
var encode = require("./encoding/encode");
var decode = require("./encoding/decode");
var ArraySchema_1 = require("./types/ArraySchema");
var MapSchema_1 = require("./types/MapSchema");
var CollectionSchema_1 = require("./types/CollectionSchema");
var SetSchema_1 = require("./types/SetSchema");
var ChangeTree_1 = require("./changes/ChangeTree");
var EventEmitter_1 = require("./events/EventEmitter");
var filters_1 = require("./filters");
var types_1 = require("./types");
var EncodeSchemaError = /** @class */ (function (_super) {
    __extends(EncodeSchemaError, _super);
    function EncodeSchemaError() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return EncodeSchemaError;
}(Error));
function assertType(value, type, klass, field) {
    var typeofTarget;
    var allowNull = false;
    switch (type) {
        case "number":
        case "int8":
        case "uint8":
        case "int16":
        case "uint16":
        case "int32":
        case "uint32":
        case "int64":
        case "uint64":
        case "float32":
        case "float64":
            typeofTarget = "number";
            if (isNaN(value)) {
                console.log("trying to encode \"NaN\" in " + klass.constructor.name + "#" + field);
            }
            break;
        case "string":
            typeofTarget = "string";
            allowNull = true;
            break;
        case "boolean":
            // boolean is always encoded as true/false based on truthiness
            return;
    }
    if (typeof (value) !== typeofTarget && (!allowNull || (allowNull && value !== null))) {
        var foundValue = "'" + JSON.stringify(value) + "'" + ((value && value.constructor && " (" + value.constructor.name + ")") || '');
        throw new EncodeSchemaError("a '" + typeofTarget + "' was expected, but " + foundValue + " was provided in " + klass.constructor.name + "#" + field);
    }
}
function assertInstanceType(value, type, klass, field) {
    if (!(value instanceof type)) {
        throw new EncodeSchemaError("a '" + type.name + "' was expected, but '" + value.constructor.name + "' was provided in " + klass.constructor.name + "#" + field);
    }
}
function encodePrimitiveType(type, bytes, value, klass, field) {
    assertType(value, type, klass, field);
    var encodeFunc = encode[type];
    if (encodeFunc) {
        encodeFunc(bytes, value);
    }
    else {
        throw new EncodeSchemaError("a '" + type + "' was expected, but " + value + " was provided in " + klass.constructor.name + "#" + field);
    }
}
function decodePrimitiveType(type, bytes, it) {
    return decode[type](bytes, it);
}
/**
 * Schema encoder / decoder
 */
var Schema = /** @class */ (function () {
    // allow inherited classes to have a constructor
    function Schema() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        // fix enumerability of fields for end-user
        Object.defineProperties(this, {
            $changes: {
                value: new ChangeTree_1.ChangeTree(this, undefined, new ChangeTree_1.Root()),
                enumerable: false,
                writable: true
            },
            $listeners: {
                value: {},
                enumerable: false,
                writable: true
            },
        });
        var descriptors = this._definition.descriptors;
        if (descriptors) {
            Object.defineProperties(this, descriptors);
        }
        //
        // Assign initial values
        //
        if (args[0]) {
            this.assign(args[0]);
        }
    }
    Schema.onError = function (e) {
        console.error(e);
    };
    Schema.is = function (type) {
        return (type['_definition'] &&
            type['_definition'].schema !== undefined);
    };
    Schema.prototype.assign = function (props) {
        Object.assign(this, props);
        return this;
    };
    Object.defineProperty(Schema.prototype, "_definition", {
        get: function () { return this.constructor._definition; },
        enumerable: false,
        configurable: true
    });
    Schema.prototype.listen = function (attr, callback) {
        var _this = this;
        if (!this.$listeners[attr]) {
            this.$listeners[attr] = new EventEmitter_1.EventEmitter();
        }
        this.$listeners[attr].register(callback);
        // return un-register callback.
        return function () {
            return _this.$listeners[attr].remove(callback);
        };
    };
    Schema.prototype.decode = function (bytes, it, ref, allChanges) {
        if (it === void 0) { it = { offset: 0 }; }
        if (ref === void 0) { ref = this; }
        if (allChanges === void 0) { allChanges = new Map(); }
        var $root = this.$changes.root;
        var totalBytes = bytes.length;
        var refId = 0;
        var changes = [];
        $root.refs.set(refId, this);
        allChanges.set(refId, changes);
        while (it.offset < totalBytes) {
            var byte = bytes[it.offset++];
            if (byte == spec_1.SWITCH_TO_STRUCTURE) {
                refId = decode.number(bytes, it);
                var nextRef = $root.refs.get(refId);
                //
                // Trying to access a reference that haven't been decoded yet.
                //
                if (!nextRef) {
                    throw new Error("\"refId\" not found: " + refId);
                }
                ref = nextRef;
                // create empty list of changes for this refId.
                changes = [];
                allChanges.set(refId, changes);
                continue;
            }
            var changeTree = ref['$changes'];
            var isSchema = (ref['_definition'] !== undefined);
            var operation = (isSchema)
                ? (byte >> 6) << 6 // "compressed" index + operation
                : byte; // "uncompressed" index + operation (array/map items)
            if (operation === spec_1.OPERATION.CLEAR) {
                //
                // TODO: refactor me!
                // The `.clear()` method is calling `$root.removeRef(refId)` for
                // each item inside this collection
                //
                ref.clear(true);
                continue;
            }
            var fieldIndex = (isSchema)
                ? byte % (operation || 255) // if "REPLACE" operation (0), use 255
                : decode.number(bytes, it);
            var fieldName = (isSchema)
                ? (ref['_definition'].fieldsByIndex[fieldIndex])
                : "";
            var type = changeTree.getType(fieldIndex);
            var value = void 0;
            var previousValue = void 0;
            var dynamicIndex = void 0;
            if (!isSchema) {
                previousValue = ref['getByIndex'](fieldIndex);
                if ((operation & spec_1.OPERATION.ADD) === spec_1.OPERATION.ADD) { // ADD or DELETE_AND_ADD
                    dynamicIndex = (ref instanceof MapSchema_1.MapSchema)
                        ? decode.string(bytes, it)
                        : fieldIndex;
                    ref['setIndex'](fieldIndex, dynamicIndex);
                }
                else {
                    // here
                    dynamicIndex = ref['getIndex'](fieldIndex);
                }
            }
            else {
                previousValue = ref["_" + fieldName];
            }
            //
            // Delete operations
            //
            if ((operation & spec_1.OPERATION.DELETE) === spec_1.OPERATION.DELETE) {
                if (operation !== spec_1.OPERATION.DELETE_AND_ADD) {
                    ref['deleteByIndex'](fieldIndex);
                }
                // Flag `refId` for garbage collection.
                if (previousValue && previousValue['$changes']) {
                    $root.removeRef(previousValue['$changes'].refId);
                }
                value = null;
            }
            if (fieldName === undefined) {
                console.warn("@colyseus/schema: definition mismatch");
                //
                // keep skipping next bytes until reaches a known structure
                // by local decoder.
                //
                var nextIterator = { offset: it.offset };
                while (it.offset < totalBytes) {
                    if (decode.switchStructureCheck(bytes, it)) {
                        nextIterator.offset = it.offset + 1;
                        if ($root.refs.has(decode.number(bytes, nextIterator))) {
                            break;
                        }
                    }
                    it.offset++;
                }
                continue;
            }
            else if (operation === spec_1.OPERATION.DELETE) {
                //
                // FIXME: refactor me.
                // Don't do anything.
                //
            }
            else if (Schema.is(type)) {
                var refId_1 = decode.number(bytes, it);
                value = $root.refs.get(refId_1);
                if (operation !== spec_1.OPERATION.REPLACE) {
                    var childType = this.getSchemaType(bytes, it, type);
                    if (!value) {
                        value = this.createTypeInstance(childType);
                        value.$changes.refId = refId_1;
                        if (previousValue) {
                            value.onChange = previousValue.onChange;
                            value.onRemove = previousValue.onRemove;
                            value.$listeners = previousValue.$listeners;
                            if (previousValue['$changes'].refId &&
                                refId_1 !== previousValue['$changes'].refId) {
                                $root.removeRef(previousValue['$changes'].refId);
                            }
                        }
                    }
                    $root.addRef(refId_1, value, (value !== previousValue));
                }
            }
            else if (typeof (type) === "string") {
                //
                // primitive value (number, string, boolean, etc)
                //
                value = decodePrimitiveType(type, bytes, it);
            }
            else {
                var typeDef = types_1.getType(Object.keys(type)[0]);
                var refId_2 = decode.number(bytes, it);
                var valueRef = ($root.refs.has(refId_2))
                    ? previousValue
                    : new typeDef.constructor();
                value = valueRef.clone(true);
                value.$changes.refId = refId_2;
                // preserve schema callbacks
                if (previousValue) {
                    value.onAdd = previousValue.onAdd;
                    value.onRemove = previousValue.onRemove;
                    value.onChange = previousValue.onChange;
                    if (previousValue['$changes'].refId &&
                        refId_2 !== previousValue['$changes'].refId) {
                        $root.removeRef(previousValue['$changes'].refId);
                        //
                        // Trigger onRemove if structure has been replaced.
                        //
                        var deletes = [];
                        var entries = previousValue.entries();
                        var iter = void 0;
                        while ((iter = entries.next()) && !iter.done) {
                            var _a = __read(iter.value, 2), key = _a[0], value_1 = _a[1];
                            deletes.push({
                                op: spec_1.OPERATION.DELETE,
                                field: key,
                                value: undefined,
                                previousValue: value_1,
                            });
                        }
                        allChanges.set(previousValue['$changes'].refId, deletes);
                    }
                }
                $root.addRef(refId_2, value, (valueRef !== previousValue));
                //
                // TODO: deprecate proxies on next version.
                // get proxy to target value.
                //
                if (typeDef.getProxy) {
                    value = typeDef.getProxy(value);
                }
            }
            var hasChange = (previousValue !== value);
            if (value !== null &&
                value !== undefined) {
                if (value['$changes']) {
                    value['$changes'].setParent(changeTree.ref, changeTree.root, fieldIndex);
                }
                if (ref instanceof Schema) {
                    ref[fieldName] = value;
                    //
                    // FIXME: use `_field` instead of `field`.
                    //
                    // `field` is going to use the setter of the PropertyDescriptor
                    // and create a proxy for array/map. This is only useful for
                    // backwards-compatibility with @colyseus/schema@0.5.x
                    //
                    // // ref[_field] = value;
                }
                else if (ref instanceof MapSchema_1.MapSchema) {
                    // const key = ref['$indexes'].get(field);
                    var key = dynamicIndex;
                    // ref.set(key, value);
                    ref['$items'].set(key, value);
                }
                else if (ref instanceof ArraySchema_1.ArraySchema) {
                    // const key = ref['$indexes'][field];
                    // console.log("SETTING FOR ArraySchema =>", { field, key, value });
                    // ref[key] = value;
                    ref.setAt(fieldIndex, value);
                }
                else if (ref instanceof CollectionSchema_1.CollectionSchema ||
                    ref instanceof SetSchema_1.SetSchema) {
                    var index = ref.add(value);
                    ref['setIndex'](fieldIndex, index);
                }
            }
            if (hasChange
            // &&
            // (
            //     this.onChange || ref.$listeners[field]
            // )
            ) {
                changes.push({
                    op: operation,
                    field: fieldName,
                    dynamicIndex: dynamicIndex,
                    value: value,
                    previousValue: previousValue,
                });
            }
        }
        this._triggerChanges(allChanges);
        // drop references of unused schemas
        $root.garbageCollectDeletedRefs();
        return allChanges;
    };
    Schema.prototype.encode = function (encodeAll, bytes, useFilters) {
        if (encodeAll === void 0) { encodeAll = false; }
        if (bytes === void 0) { bytes = []; }
        if (useFilters === void 0) { useFilters = false; }
        var rootChangeTree = this.$changes;
        var refIdsVisited = new WeakSet();
        var changeTrees = [rootChangeTree];
        var numChangeTrees = 1;
        for (var i = 0; i < numChangeTrees; i++) {
            var changeTree = changeTrees[i];
            var ref = changeTree.ref;
            var isSchema = (ref instanceof Schema);
            // Generate unique refId for the ChangeTree.
            changeTree.ensureRefId();
            // mark this ChangeTree as visited.
            refIdsVisited.add(changeTree);
            // root `refId` is skipped.
            if (changeTree !== rootChangeTree &&
                (changeTree.changed || encodeAll)) {
                encode.uint8(bytes, spec_1.SWITCH_TO_STRUCTURE);
                encode.number(bytes, changeTree.refId);
            }
            var changes = (encodeAll)
                ? Array.from(changeTree.allChanges)
                : Array.from(changeTree.changes.values());
            for (var j = 0, cl = changes.length; j < cl; j++) {
                var operation = (encodeAll)
                    ? { op: spec_1.OPERATION.ADD, index: changes[j] }
                    : changes[j];
                var fieldIndex = operation.index;
                var field = (isSchema)
                    ? ref['_definition'].fieldsByIndex && ref['_definition'].fieldsByIndex[fieldIndex]
                    : fieldIndex;
                // cache begin index if `useFilters`
                var beginIndex = bytes.length;
                // encode field index + operation
                if (operation.op !== spec_1.OPERATION.TOUCH) {
                    if (isSchema) {
                        //
                        // Compress `fieldIndex` + `operation` into a single byte.
                        // This adds a limitaion of 64 fields per Schema structure
                        //
                        encode.uint8(bytes, (fieldIndex | operation.op));
                    }
                    else {
                        encode.uint8(bytes, operation.op);
                        // custom operations
                        if (operation.op === spec_1.OPERATION.CLEAR) {
                            continue;
                        }
                        // indexed operations
                        encode.number(bytes, fieldIndex);
                    }
                }
                //
                // encode "alias" for dynamic fields (maps)
                //
                if (!isSchema &&
                    (operation.op & spec_1.OPERATION.ADD) == spec_1.OPERATION.ADD // ADD or DELETE_AND_ADD
                ) {
                    if (ref instanceof MapSchema_1.MapSchema) {
                        //
                        // MapSchema dynamic key
                        //
                        var dynamicIndex = changeTree.ref['$indexes'].get(fieldIndex);
                        encode.string(bytes, dynamicIndex);
                    }
                }
                if (operation.op === spec_1.OPERATION.DELETE) {
                    //
                    // TODO: delete from filter cache data.
                    //
                    // if (useFilters) {
                    //     delete changeTree.caches[fieldIndex];
                    // }
                    continue;
                }
                // const type = changeTree.childType || ref._schema[field];
                var type = changeTree.getType(fieldIndex);
                // const type = changeTree.getType(fieldIndex);
                var value = changeTree.getValue(fieldIndex);
                // Enqueue ChangeTree to be visited
                if (value &&
                    value['$changes'] &&
                    !refIdsVisited.has(value['$changes'])) {
                    changeTrees.push(value['$changes']);
                    value['$changes'].ensureRefId();
                    numChangeTrees++;
                }
                if (operation.op === spec_1.OPERATION.TOUCH) {
                    continue;
                }
                if (Schema.is(type)) {
                    assertInstanceType(value, type, ref, field);
                    //
                    // Encode refId for this instance.
                    // The actual instance is going to be encoded on next `changeTree` iteration.
                    //
                    encode.number(bytes, value.$changes.refId);
                    // Try to encode inherited TYPE_ID if it's an ADD operation.
                    if ((operation.op & spec_1.OPERATION.ADD) === spec_1.OPERATION.ADD) {
                        this.tryEncodeTypeId(bytes, type, value.constructor);
                    }
                }
                else if (typeof (type) === "string") {
                    //
                    // Primitive values
                    //
                    encodePrimitiveType(type, bytes, value, ref, field);
                }
                else {
                    //
                    // Custom type (MapSchema, ArraySchema, etc)
                    //
                    var definition = types_1.getType(Object.keys(type)[0]);
                    //
                    // ensure a ArraySchema has been provided
                    //
                    assertInstanceType(ref["_" + field], definition.constructor, ref, field);
                    //
                    // Encode refId for this instance.
                    // The actual instance is going to be encoded on next `changeTree` iteration.
                    //
                    encode.number(bytes, value.$changes.refId);
                }
                if (useFilters) {
                    // cache begin / end index
                    changeTree.cache(fieldIndex, bytes.slice(beginIndex));
                }
            }
            if (!encodeAll && !useFilters) {
                changeTree.discard();
            }
        }
        return bytes;
    };
    Schema.prototype.encodeAll = function (useFilters) {
        return this.encode(true, [], useFilters);
    };
    Schema.prototype.applyFilters = function (client, encodeAll) {
        if (encodeAll === void 0) { encodeAll = false; }
        var root = this;
        var refIdsDissallowed = new Set();
        var $filterState = filters_1.ClientState.get(client);
        var changeTrees = [this.$changes];
        var numChangeTrees = 1;
        var filteredBytes = [];
        var _loop_1 = function (i) {
            var changeTree = changeTrees[i];
            if (refIdsDissallowed.has(changeTree.refId)) {
                return "continue";
            }
            var ref = changeTree.ref;
            var isSchema = ref instanceof Schema;
            encode.uint8(filteredBytes, spec_1.SWITCH_TO_STRUCTURE);
            encode.number(filteredBytes, changeTree.refId);
            var clientHasRefId = $filterState.refIds.has(changeTree);
            var isEncodeAll = (encodeAll || !clientHasRefId);
            // console.log("REF:", ref.constructor.name);
            // console.log("Encode all?", isEncodeAll);
            //
            // include `changeTree` on list of known refIds by this client.
            //
            $filterState.addRefId(changeTree);
            var containerIndexes = $filterState.containerIndexes.get(changeTree);
            var changes = (isEncodeAll)
                ? Array.from(changeTree.allChanges)
                : Array.from(changeTree.changes.values());
            //
            // WORKAROUND: tries to re-evaluate previously not included @filter() attributes
            // - see "DELETE a field of Schema" test case.
            //
            if (!encodeAll &&
                isSchema &&
                ref._definition.indexesWithFilters) {
                var indexesWithFilters = ref._definition.indexesWithFilters;
                indexesWithFilters.forEach(function (indexWithFilter) {
                    if (!containerIndexes.has(indexWithFilter) &&
                        changeTree.allChanges.has(indexWithFilter)) {
                        if (isEncodeAll) {
                            changes.push(indexWithFilter);
                        }
                        else {
                            changes.push({ op: spec_1.OPERATION.ADD, index: indexWithFilter, });
                        }
                    }
                });
            }
            for (var j = 0, cl = changes.length; j < cl; j++) {
                var change = (isEncodeAll)
                    ? { op: spec_1.OPERATION.ADD, index: changes[j] }
                    : changes[j];
                // custom operations
                if (change.op === spec_1.OPERATION.CLEAR) {
                    encode.uint8(filteredBytes, change.op);
                    continue;
                }
                var fieldIndex = change.index;
                //
                // Deleting fields: encode the operation + field index
                //
                if (change.op === spec_1.OPERATION.DELETE) {
                    //
                    // DELETE operations also need to go through filtering.
                    //
                    // TODO: cache the previous value so we can access the value (primitive or `refId`)
                    // (check against `$filterState.refIds`)
                    //
                    if (isSchema) {
                        encode.uint8(filteredBytes, change.op | fieldIndex);
                    }
                    else {
                        encode.uint8(filteredBytes, change.op);
                        encode.number(filteredBytes, fieldIndex);
                    }
                    continue;
                }
                // indexed operation
                var value = changeTree.getValue(fieldIndex);
                var type = changeTree.getType(fieldIndex);
                if (isSchema) {
                    // Is a Schema!
                    var filter = (ref._definition.filters &&
                        ref._definition.filters[fieldIndex]);
                    if (filter && !filter.call(ref, client, value, root)) {
                        if (value && value['$changes']) {
                            refIdsDissallowed.add(value['$changes'].refId);
                            ;
                        }
                        continue;
                    }
                }
                else {
                    // Is a collection! (map, array, etc.)
                    var parent = changeTree.parent;
                    var filter = changeTree.getChildrenFilter();
                    if (filter && !filter.call(parent, client, ref['$indexes'].get(fieldIndex), value, root)) {
                        if (value && value['$changes']) {
                            refIdsDissallowed.add(value['$changes'].refId);
                        }
                        continue;
                    }
                }
                // visit child ChangeTree on further iteration.
                if (value['$changes']) {
                    changeTrees.push(value['$changes']);
                    numChangeTrees++;
                }
                //
                // Copy cached bytes
                //
                if (change.op !== spec_1.OPERATION.TOUCH) {
                    //
                    // TODO: refactor me!
                    //
                    if (change.op === spec_1.OPERATION.ADD || isSchema) {
                        //
                        // use cached bytes directly if is from Schema type.
                        //
                        filteredBytes = filteredBytes.concat(changeTree.caches[fieldIndex]);
                        containerIndexes.add(fieldIndex);
                    }
                    else {
                        if (containerIndexes.has(fieldIndex)) {
                            //
                            // use cached bytes if already has the field
                            //
                            filteredBytes = filteredBytes.concat(changeTree.caches[fieldIndex]);
                        }
                        else {
                            //
                            // force ADD operation if field is not known by this client.
                            //
                            containerIndexes.add(fieldIndex);
                            encode.uint8(filteredBytes, spec_1.OPERATION.ADD);
                            encode.number(filteredBytes, fieldIndex);
                            if (ref instanceof MapSchema_1.MapSchema) {
                                //
                                // MapSchema dynamic key
                                //
                                var dynamicIndex = changeTree.ref['$indexes'].get(fieldIndex);
                                encode.string(filteredBytes, dynamicIndex);
                            }
                            if (value['$changes']) {
                                encode.number(filteredBytes, value['$changes'].refId);
                            }
                            else {
                                // "encodePrimitiveType" without type checking.
                                // the type checking has been done on the first .encode() call.
                                encode[type](filteredBytes, value);
                            }
                        }
                    }
                }
                else if (value['$changes'] && !isSchema) {
                    //
                    // TODO:
                    // - track ADD/REPLACE/DELETE instances on `$filterState`
                    // - do NOT always encode dynamicIndex for MapSchema.
                    //   (If client already has that key, only the first index is necessary.)
                    //
                    encode.uint8(filteredBytes, spec_1.OPERATION.ADD);
                    encode.number(filteredBytes, fieldIndex);
                    if (ref instanceof MapSchema_1.MapSchema) {
                        //
                        // MapSchema dynamic key
                        //
                        var dynamicIndex = changeTree.ref['$indexes'].get(fieldIndex);
                        encode.string(filteredBytes, dynamicIndex);
                    }
                    encode.number(filteredBytes, value['$changes'].refId);
                }
            }
            ;
        };
        for (var i = 0; i < numChangeTrees; i++) {
            _loop_1(i);
        }
        return filteredBytes;
    };
    Schema.prototype.clone = function () {
        var cloned = new (this.constructor);
        var schema = this._definition.schema;
        for (var field in schema) {
            if (typeof (this[field]) === "object" &&
                typeof (this[field].clone) === "function") {
                // deep clone
                cloned[field] = this[field].clone();
            }
            else {
                // primitive values
                cloned[field] = this[field];
            }
        }
        return cloned;
    };
    Schema.prototype.triggerAll = function () {
        // skip if haven't received any remote refs yet.
        if (this.$changes.root.refs.size === 0) {
            return;
        }
        var allChanges = new Map();
        Schema.prototype._triggerAllFillChanges.call(this, this, allChanges);
        try {
            Schema.prototype._triggerChanges.call(this, allChanges);
        }
        catch (e) {
            Schema.onError(e);
        }
    };
    Schema.prototype.toJSON = function () {
        var schema = this._definition.schema;
        var deprecated = this._definition.deprecated;
        var obj = {};
        for (var field in schema) {
            if (!deprecated[field] && this[field] !== null && typeof (this[field]) !== "undefined") {
                obj[field] = (typeof (this[field]['toJSON']) === "function")
                    ? this[field]['toJSON']()
                    : this["_" + field];
            }
        }
        return obj;
    };
    Schema.prototype.discardAllChanges = function () {
        this.$changes.discardAll();
    };
    Schema.prototype.getByIndex = function (index) {
        return this[this._definition.fieldsByIndex[index]];
    };
    Schema.prototype.deleteByIndex = function (index) {
        this[this._definition.fieldsByIndex[index]] = undefined;
    };
    Schema.prototype.tryEncodeTypeId = function (bytes, type, targetType) {
        if (type._typeid !== targetType._typeid) {
            encode.uint8(bytes, spec_1.TYPE_ID);
            encode.number(bytes, targetType._typeid);
        }
    };
    Schema.prototype.getSchemaType = function (bytes, it, defaultType) {
        var type;
        if (bytes[it.offset] === spec_1.TYPE_ID) {
            it.offset++;
            type = this.constructor._context.get(decode.number(bytes, it));
        }
        return type || defaultType;
    };
    Schema.prototype.createTypeInstance = function (type) {
        var instance = new type();
        // assign root on $changes
        instance.$changes.root = this.$changes.root;
        return instance;
    };
    Schema.prototype._triggerAllFillChanges = function (ref, allChanges) {
        if (allChanges.has(ref['$changes'].refId)) {
            return;
        }
        var changes = [];
        allChanges.set(ref['$changes'].refId || 0, changes);
        if (ref instanceof Schema) {
            var schema = ref._definition.schema;
            for (var fieldName in schema) {
                var _field = "_" + fieldName;
                var value = ref[_field];
                if (value !== undefined) {
                    changes.push({
                        op: spec_1.OPERATION.ADD,
                        field: fieldName,
                        value: value,
                        previousValue: undefined
                    });
                    if (value['$changes'] !== undefined) {
                        Schema.prototype._triggerAllFillChanges.call(this, value, allChanges);
                    }
                }
            }
        }
        else {
            var entries = ref.entries();
            var iter = void 0;
            while ((iter = entries.next()) && !iter.done) {
                var _a = __read(iter.value, 2), key = _a[0], value = _a[1];
                changes.push({
                    op: spec_1.OPERATION.ADD,
                    field: key,
                    dynamicIndex: key,
                    value: value,
                    previousValue: undefined,
                });
                if (value['$changes'] !== undefined) {
                    Schema.prototype._triggerAllFillChanges.call(this, value, allChanges);
                }
            }
        }
    };
    Schema.prototype._triggerChanges = function (allChanges) {
        var _this = this;
        allChanges.forEach(function (changes, refId) {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
            if (changes.length > 0) {
                var ref = _this.$changes.root.refs.get(refId);
                var isSchema = ref instanceof Schema;
                for (var i = 0; i < changes.length; i++) {
                    var change = changes[i];
                    var listener = ref['$listeners'] && ref['$listeners'][change.field];
                    if (!isSchema) {
                        if (change.op === spec_1.OPERATION.ADD && change.previousValue === undefined) {
                            (_b = (_a = ref).onAdd) === null || _b === void 0 ? void 0 : _b.call(_a, change.value, (_c = change.dynamicIndex) !== null && _c !== void 0 ? _c : change.field);
                        }
                        else if (change.op === spec_1.OPERATION.DELETE) {
                            //
                            // FIXME: `previousValue` should always be avaiiable.
                            // ADD + DELETE operations are still encoding DELETE operation.
                            //
                            if (change.previousValue !== undefined) {
                                (_e = (_d = ref).onRemove) === null || _e === void 0 ? void 0 : _e.call(_d, change.previousValue, (_f = change.dynamicIndex) !== null && _f !== void 0 ? _f : change.field);
                            }
                        }
                        else if (change.op === spec_1.OPERATION.DELETE_AND_ADD) {
                            if (change.previousValue !== undefined) {
                                (_h = (_g = ref).onRemove) === null || _h === void 0 ? void 0 : _h.call(_g, change.previousValue, change.dynamicIndex);
                            }
                            (_k = (_j = ref).onAdd) === null || _k === void 0 ? void 0 : _k.call(_j, change.value, change.dynamicIndex);
                        }
                        else if (change.op === spec_1.OPERATION.REPLACE ||
                            change.value !== change.previousValue) {
                            (_m = (_l = ref).onChange) === null || _m === void 0 ? void 0 : _m.call(_l, change.value, change.dynamicIndex);
                        }
                    }
                    //
                    // trigger onRemove on child structure.
                    //
                    if ((change.op & spec_1.OPERATION.DELETE) === spec_1.OPERATION.DELETE &&
                        change.previousValue instanceof Schema &&
                        change.previousValue.onRemove) {
                        change.previousValue.onRemove();
                    }
                    if (listener) {
                        try {
                            listener.invoke(change.value, change.previousValue);
                        }
                        catch (e) {
                            Schema.onError(e);
                        }
                    }
                }
                if (isSchema) {
                    if (ref.onChange) {
                        try {
                            ref.onChange(changes);
                        }
                        catch (e) {
                            Schema.onError(e);
                        }
                    }
                }
            }
        });
    };
    Schema._definition = annotations_1.SchemaDefinition.create();
    return Schema;
}());
exports.Schema = Schema;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU2NoZW1hLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vc3JjL1NjaGVtYS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLCtCQUFpRTtBQUNqRSw2Q0FBaUc7QUFFakcsMENBQTRDO0FBQzVDLDBDQUE0QztBQUU1QyxtREFBaUU7QUFDakUsK0NBQTJEO0FBQzNELDZEQUE0RDtBQUM1RCwrQ0FBOEM7QUFFOUMsbURBQThFO0FBRTlFLHNEQUFxRDtBQUNyRCxxQ0FBd0M7QUFDeEMsaUNBQWtDO0FBbUJsQztJQUFnQyxxQ0FBSztJQUFyQzs7SUFBdUMsQ0FBQztJQUFELHdCQUFDO0FBQUQsQ0FBQyxBQUF4QyxDQUFnQyxLQUFLLEdBQUc7QUFFeEMsU0FBUyxVQUFVLENBQUMsS0FBVSxFQUFFLElBQVksRUFBRSxLQUFhLEVBQUUsS0FBc0I7SUFDL0UsSUFBSSxZQUFvQixDQUFDO0lBQ3pCLElBQUksU0FBUyxHQUFZLEtBQUssQ0FBQztJQUUvQixRQUFRLElBQUksRUFBRTtRQUNWLEtBQUssUUFBUSxDQUFDO1FBQ2QsS0FBSyxNQUFNLENBQUM7UUFDWixLQUFLLE9BQU8sQ0FBQztRQUNiLEtBQUssT0FBTyxDQUFDO1FBQ2IsS0FBSyxRQUFRLENBQUM7UUFDZCxLQUFLLE9BQU8sQ0FBQztRQUNiLEtBQUssUUFBUSxDQUFDO1FBQ2QsS0FBSyxPQUFPLENBQUM7UUFDYixLQUFLLFFBQVEsQ0FBQztRQUNkLEtBQUssU0FBUyxDQUFDO1FBQ2YsS0FBSyxTQUFTO1lBQ1YsWUFBWSxHQUFHLFFBQVEsQ0FBQztZQUN4QixJQUFJLEtBQUssQ0FBQyxLQUFLLENBQUMsRUFBRTtnQkFDZCxPQUFPLENBQUMsR0FBRyxDQUFDLGlDQUE2QixLQUFLLENBQUMsV0FBVyxDQUFDLElBQUksU0FBSSxLQUFPLENBQUMsQ0FBQzthQUMvRTtZQUNELE1BQU07UUFDVixLQUFLLFFBQVE7WUFDVCxZQUFZLEdBQUcs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UEVfSUQsIE9QRVJBVElPTiB9IGZyb20gJy4vc3BlYyc7XG5pbXBvcnQgeyBDbGllbnQsIFByaW1pdGl2ZVR5cGUsIENvbnRleHQsIFNjaGVtYURlZmluaXRpb24sIERlZmluaXRpb25UeXBlIH0gZnJvbSBcIi4vYW5ub3RhdGlvbnNcIjtcblxuaW1wb3J0ICogYXMgZW5jb2RlIGZyb20gXCIuL2VuY29kaW5nL2VuY29kZVwiO1xuaW1wb3J0ICogYXMgZGVjb2RlIGZyb20gXCIuL2VuY29kaW5nL2RlY29kZVwiO1xuXG5pbXBvcnQgeyBBcnJheVNjaGVtYSwgZ2V0QXJyYXlQcm94eSB9IGZyb20gXCIuL3R5cGVzL0FycmF5U2NoZW1hXCI7XG5pbXBvcnQgeyBNYXBTY2hlbWEsIGdldE1hcFByb3h5IH0gZnJvbSBcIi4vdHlwZXMvTWFwU2NoZW1hXCI7XG5pbXBvcnQgeyBDb2xsZWN0aW9uU2NoZW1hIH0gZnJvbSAnLi90eXBlcy9Db2xsZWN0aW9uU2NoZW1hJztcbmltcG9ydCB7IFNldFNjaGVtYSB9IGZyb20gJy4vdHlwZXMvU2V0U2NoZW1hJztcblxuaW1wb3J0IHsgQ2hhbmdlVHJlZSwgUm9vdCwgUmVmLCBDaGFuZ2VPcGVyYXRpb24gfSBmcm9tIFwiLi9jaGFuZ2VzL0NoYW5nZVRyZWVcIjtcbmltcG9ydCB7IE5vbkZ1bmN0aW9uUHJvcE5hbWVzIH0gZnJvbSAnLi90eXBlcy9IZWxwZXJUeXBlcyc7XG5pbXBvcnQgeyBFdmVudEVtaXR0ZXIgfSBmcm9tICcuL2V2ZW50cy9FdmVudEVtaXR0ZXInO1xuaW1wb3J0IHsgQ2xpZW50U3RhdGUgfSBmcm9tICcuL2ZpbHRlcnMnO1xuaW1wb3J0IHsgZ2V0VHlwZSB9IGZyb20gJy4vdHlwZXMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIERhdGFDaGFuZ2U8VD1hbnk+IHtcbiAgICBvcDogT1BFUkFUSU9OLFxuICAgIGZpZWxkOiBzdHJpbmc7XG4gICAgZHluYW1pY0luZGV4PzogbnVtYmVyIHwgc3RyaW5nO1xuICAgIHZhbHVlOiBUO1xuICAgIHByZXZpb3VzVmFsdWU6IFQ7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2NoZW1hRGVjb2RlckNhbGxiYWNrcyB7XG4gICAgb25BZGQ/OiAoaXRlbTogYW55LCBrZXk6IGFueSkgPT4gdm9pZDtcbiAgICBvblJlbW92ZT86IChpdGVtOiBhbnksIGtleTogYW55KSA9PiB2b2lkO1xuICAgIG9uQ2hhbmdlPzogKGl0ZW06IGFueSwga2V5OiBhbnkpID0+IHZvaWQ7XG4gICAgY2xvbmUoZGVjb2Rpbmc/OiBib29sZWFuKTogU2NoZW1hRGVjb2RlckNhbGxiYWNrcztcbiAgICBjbGVhcihkZWNvZGluZz86IGJvb2xlYW4pO1xuICAgIGRlY29kZT8oYnl0ZSwgaXQ6IGRlY29kZS5JdGVyYXRvcik7XG59XG5cbmNsYXNzIEVuY29kZVNjaGVtYUVycm9yIGV4dGVuZHMgRXJyb3Ige31cblxuZnVuY3Rpb24gYXNzZXJ0VHlwZSh2YWx1ZTogYW55LCB0eXBlOiBzdHJpbmcsIGtsYXNzOiBTY2hlbWEsIGZpZWxkOiBzdHJpbmcgfCBudW1iZXIpIHtcbiAgICBsZXQgdHlwZW9mVGFyZ2V0OiBzdHJpbmc7XG4gICAgbGV0IGFsbG93TnVsbDogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgY2FzZSBcImludDhcIjpcbiAgICAgICAgY2FzZSBcInVpbnQ4XCI6XG4gICAgICAgIGNhc2UgXCJpbnQxNlwiOlxuICAgICAgICBjYXNlIFwidWludDE2XCI6XG4gICAgICAgIGNhc2UgXCJpbnQzMlwiOlxuICAgICAgICBjYXNlIFwidWludDMyXCI6XG4gICAgICAgIGNhc2UgXCJpbnQ2NFwiOlxuICAgICAgICBjYXNlIFwidWludDY0XCI6XG4gICAgICAgIGNhc2UgXCJmbG9hdDMyXCI6XG4gICAgICAgIGNhc2UgXCJmbG9hdDY0XCI6XG4gICAgICAgICAgICB0eXBlb2ZUYXJnZXQgPSBcIm51bWJlclwiO1xuICAgICAgICAgICAgaWYgKGlzTmFOKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGB0cnlpbmcgdG8gZW5jb2RlIFwiTmFOXCIgaW4gJHtrbGFzcy5jb25zdHJ1Y3Rvci5uYW1lfSMke2ZpZWxkfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgIHR5cGVvZlRhcmdldCA9IFwic3RyaW5nXCI7XG4gICAgICAgICAgICBhbGxvd051bGwgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICAgICAgICAvLyBib29sZWFuIGlzIGFsd2F5cyBlbmNvZGVkIGFzIHRydWUvZmFsc2UgYmFzZWQgb24gdHJ1dGhpbmVzc1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgKHZhbHVlKSAhPT0gdHlwZW9mVGFyZ2V0ICYmICghYWxsb3dOdWxsIHx8IChhbGxvd051bGwgJiYgdmFsdWUgIT09IG51bGwpKSkge1xuICAgICAgICBsZXQgZm91bmRWYWx1ZSA9IGAnJHtKU09OLnN0cmluZ2lmeSh2YWx1ZSl9JyR7KHZhbHVlICYmIHZhbHVlLmNvbnN0cnVjdG9yICYmIGAgKCR7dmFsdWUuY29uc3RydWN0b3IubmFtZX0pYCkgfHwgJyd9YDtcbiAgICAgICAgdGhyb3cgbmV3IEVuY29kZVNjaGVtYUVycm9yKGBhICcke3R5cGVvZlRhcmdldH0nIHdhcyBleHBlY3RlZCwgYnV0ICR7Zm91bmRWYWx1ZX0gd2FzIHByb3ZpZGVkIGluICR7a2xhc3MuY29uc3RydWN0b3IubmFtZX0jJHtmaWVsZH1gKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGFzc2VydEluc3RhbmNlVHlwZShcbiAgICB2YWx1ZTogU2NoZW1hLFxuICAgIHR5cGU6IHR5cGVvZiBTY2hlbWFcbiAgICAgICAgfCB0eXBlb2YgQXJyYXlTY2hlbWFcbiAgICAgICAgfCB0eXBlb2YgTWFwU2NoZW1hXG4gICAgICAgIHwgdHlwZW9mIENvbGxlY3Rpb25TY2hlbWFcbiAgICAgICAgfCB0eXBlb2YgU2V0U2NoZW1hLFxuICAgIGtsYXNzOiBTY2hlbWEsXG4gICAgZmllbGQ6IHN0cmluZyB8IG51bWJlcixcbikge1xuICAgIGlmICghKHZhbHVlIGluc3RhbmNlb2YgdHlwZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVuY29kZVNjaGVtYUVycm9yKGBhICcke3R5cGUubmFtZX0nIHdhcyBleHBlY3RlZCwgYnV0ICckeyh2YWx1ZSBhcyBhbnkpLmNvbnN0cnVjdG9yLm5hbWV9JyB3YXMgcHJvdmlkZWQgaW4gJHtrbGFzcy5jb25zdHJ1Y3Rvci5uYW1lfSMke2ZpZWxkfWApO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZW5jb2RlUHJpbWl0aXZlVHlwZShcbiAgICB0eXBlOiBQcmltaXRpdmVUeXBlLFxuICAgIGJ5dGVzOiBudW1iZXJbXSxcbiAgICB2YWx1ZTogYW55LFxuICAgIGtsYXNzOiBTY2hlbWEsXG4gICAgZmllbGQ6IHN0cmluZyB8IG51bWJlcixcbikge1xuICAgIGFzc2VydFR5cGUodmFsdWUsIHR5cGUgYXMgc3RyaW5nLCBrbGFzcywgZmllbGQpO1xuXG4gICAgY29uc3QgZW5jb2RlRnVuYyA9IGVuY29kZVt0eXBlIGFzIHN0cmluZ107XG5cbiAgICBpZiAoZW5jb2RlRnVuYykge1xuICAgICAgICBlbmNvZGVGdW5jKGJ5dGVzLCB2YWx1ZSk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRW5jb2RlU2NoZW1hRXJyb3IoYGEgJyR7dHlwZX0nIHdhcyBleHBlY3RlZCwgYnV0ICR7dmFsdWV9IHdhcyBwcm92aWRlZCBpbiAke2tsYXNzLmNvbnN0cnVjdG9yLm5hbWV9IyR7ZmllbGR9YCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkZWNvZGVQcmltaXRpdmVUeXBlICh0eXBlOiBzdHJpbmcsIGJ5dGVzOiBudW1iZXJbXSwgaXQ6IGRlY29kZS5JdGVyYXRvcikge1xuICAgIHJldHVybiBkZWNvZGVbdHlwZSBhcyBzdHJpbmddKGJ5dGVzLCBpdCk7XG59XG5cbi8qKlxuICogU2NoZW1hIGVuY29kZXIgLyBkZWNvZGVyXG4gKi9cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBTY2hlbWEge1xuICAgIHN0YXRpYyBfdHlwZWlkOiBudW1iZXI7XG4gICAgc3RhdGljIF9jb250ZXh0OiBDb250ZXh0O1xuXG4gICAgc3RhdGljIF9kZWZpbml0aW9uOiBTY2hlbWFEZWZpbml0aW9uID0gU2NoZW1hRGVmaW5pdGlvbi5jcmVhdGUoKTtcblxuICAgIHN0YXRpYyBvbkVycm9yKGUpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgaXModHlwZTogRGVmaW5pdGlvblR5cGUpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHR5cGVbJ19kZWZpbml0aW9uJ10gJiZcbiAgICAgICAgICAgIHR5cGVbJ19kZWZpbml0aW9uJ10uc2NoZW1hICE9PSB1bmRlZmluZWRcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgJGNoYW5nZXM6IENoYW5nZVRyZWU7XG4gICAgLy8gcHJvdGVjdGVkICRyb290OiBDaGFuZ2VTZXQ7XG5cbiAgICBwcm90ZWN0ZWQgJGxpc3RlbmVyczogeyBbZmllbGQ6IHN0cmluZ106IEV2ZW50RW1pdHRlcjwoYTogYW55LCBiOiBhbnkpID0+IHZvaWQ+IH07XG5cbiAgICBwdWJsaWMgb25DaGFuZ2U/KGNoYW5nZXM6IERhdGFDaGFuZ2VbXSk7XG4gICAgcHVibGljIG9uUmVtb3ZlPygpO1xuXG4gICAgLy8gYWxsb3cgaW5oZXJpdGVkIGNsYXNzZXMgdG8gaGF2ZSBhIGNvbnN0cnVjdG9yXG4gICAgY29uc3RydWN0b3IoLi4uYXJnczogYW55W10pIHtcbiAgICAgICAgLy8gZml4IGVudW1lcmFiaWxpdHkgb2YgZmllbGRzIGZvciBlbmQtdXNlclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgICAgICAgICAkY2hhbmdlczoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBuZXcgQ2hhbmdlVHJlZSh0aGlzLCB1bmRlZmluZWQsIG5ldyBSb290KCkpLFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAkbGlzdGVuZXJzOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IHt9LFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCBkZXNjcmlwdG9ycyA9IHRoaXMuX2RlZmluaXRpb24uZGVzY3JpcHRvcnM7XG4gICAgICAgIGlmIChkZXNjcmlwdG9ycykge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGhpcywgZGVzY3JpcHRvcnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gQXNzaWduIGluaXRpYWwgdmFsdWVzXG4gICAgICAgIC8vXG4gICAgICAgIGlmIChhcmdzWzBdKSB7XG4gICAgICAgICAgICB0aGlzLmFzc2lnbihhcmdzWzBdKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHB1YmxpYyBhc3NpZ24oXG4gICAgICAgIHByb3BzOiB7IFtwcm9wIGluIE5vbkZ1bmN0aW9uUHJvcE5hbWVzPHRoaXM+XT86IHRoaXNbcHJvcF0gfVxuICAgICkge1xuICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMsIHByb3BzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIGdldCBfZGVmaW5pdGlvbiAoKSB7IHJldHVybiAodGhpcy5jb25zdHJ1Y3RvciBhcyB0eXBlb2YgU2NoZW1hKS5fZGVmaW5pdGlvbjsgfVxuXG4gICAgcHVibGljIGxpc3RlbiA8SyBleHRlbmRzIE5vbkZ1bmN0aW9uUHJvcE5hbWVzPHRoaXM+PihhdHRyOiBLLCBjYWxsYmFjazogKHZhbHVlOiB0aGlzW0tdLCBwcmV2aW91c1ZhbHVlOiB0aGlzW0tdKSA9PiB2b2lkKSB7XG4gICAgICAgIGlmICghdGhpcy4kbGlzdGVuZXJzW2F0dHIgYXMgc3RyaW5nXSkge1xuICAgICAgICAgICAgdGhpcy4kbGlzdGVuZXJzW2F0dHIgYXMgc3RyaW5nXSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiRsaXN0ZW5lcnNbYXR0ciBhcyBzdHJpbmddLnJlZ2lzdGVyKGNhbGxiYWNrKTtcblxuICAgICAgICAvLyByZXR1cm4gdW4tcmVnaXN0ZXIgY2FsbGJhY2suXG4gICAgICAgIHJldHVybiAoKSA9PlxuICAgICAgICAgICAgdGhpcy4kbGlzdGVuZXJzW2F0dHIgYXMgc3RyaW5nXS5yZW1vdmUoY2FsbGJhY2spO1xuICAgIH1cblxuICAgIGRlY29kZShcbiAgICAgICAgYnl0ZXM6IG51bWJlcltdLFxuICAgICAgICBpdDogZGVjb2RlLkl0ZXJhdG9yID0geyBvZmZzZXQ6IDAgfSxcbiAgICAgICAgcmVmOiBSZWYgPSB0aGlzLFxuICAgICAgICBhbGxDaGFuZ2VzOiBNYXA8bnVtYmVyLCBEYXRhQ2hhbmdlW10+ID0gbmV3IE1hcDxudW1iZXIsIERhdGFDaGFuZ2VbXT4oKSxcbiAgICApIHtcbiAgICAgICAgY29uc3QgJHJvb3QgPSB0aGlzLiRjaGFuZ2VzLnJvb3Q7XG4gICAgICAgIGNvbnN0IHRvdGFsQnl0ZXMgPSBieXRlcy5sZW5ndGg7XG5cbiAgICAgICAgbGV0IHJlZklkOiBudW1iZXIgPSAwO1xuICAgICAgICBsZXQgY2hhbmdlczogRGF0YUNoYW5nZVtdID0gW107XG5cbiAgICAgICAgJHJvb3QucmVmcy5zZXQocmVmSWQsIHRoaXMpO1xuICAgICAgICBhbGxDaGFuZ2VzLnNldChyZWZJZCwgY2hhbmdlcyk7XG5cbiAgICAgICAgd2hpbGUgKGl0Lm9mZnNldCA8IHRvdGFsQnl0ZXMpIHtcbiAgICAgICAgICAgIGxldCBieXRlID0gYnl0ZXNbaXQub2Zmc2V0KytdO1xuXG4gICAgICAgICAgICBpZiAoYnl0ZSA9PSBTV0lUQ0hfVE9fU1RSVUNUVVJFKSB7XG4gICAgICAgICAgICAgICAgcmVmSWQgPSBkZWNvZGUubnVtYmVyKGJ5dGVzLCBpdCk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0UmVmID0gJHJvb3QucmVmcy5nZXQocmVmSWQpIGFzIFNjaGVtYTtcblxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gVHJ5aW5nIHRvIGFjY2VzcyBhIHJlZmVyZW5jZSB0aGF0IGhhdmVuJ3QgYmVlbiBkZWNvZGVkIHlldC5cbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIGlmICghbmV4dFJlZikgeyB0aHJvdyBuZXcgRXJyb3IoYFwicmVmSWRcIiBub3QgZm91bmQ6ICR7cmVmSWR9YCk7IH1cblxuICAgICAgICAgICAgICAgIHJlZiA9IG5leHRSZWY7XG5cbiAgICAgICAgICAgICAgICAvLyBjcmVhdGUgZW1wdHkgbGlzdCBvZiBjaGFuZ2VzIGZvciB0aGlzIHJlZklkLlxuICAgICAgICAgICAgICAgIGNoYW5nZXMgPSBbXTtcbiAgICAgICAgICAgICAgICBhbGxDaGFuZ2VzLnNldChyZWZJZCwgY2hhbmdlcyk7XG5cbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgY2hhbmdlVHJlZTogQ2hhbmdlVHJlZSA9IHJlZlsnJGNoYW5nZXMnXTtcbiAgICAgICAgICAgIGNvbnN0IGlzU2NoZW1hID0gKHJlZlsnX2RlZmluaXRpb24nXSAhPT0gdW5kZWZpbmVkKTtcblxuICAgICAgICAgICAgY29uc3Qgb3BlcmF0aW9uID0gKGlzU2NoZW1hKVxuICAgICAgICAgICAgICAgID8gKGJ5dGUgPj4gNikgPDwgNiAvLyBcImNvbXByZXNzZWRcIiBpbmRleCArIG9wZXJhdGlvblxuICAgICAgICAgICAgICAgIDogYnl0ZTsgLy8gXCJ1bmNvbXByZXNzZWRcIiBpbmRleCArIG9wZXJhdGlvbiAoYXJyYXkvbWFwIGl0ZW1zKVxuXG4gICAgICAgICAgICBpZiAob3BlcmF0aW9uID09PSBPUEVSQVRJT04uQ0xFQVIpIHtcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IHJlZmFjdG9yIG1lIVxuICAgICAgICAgICAgICAgIC8vIFRoZSBgLmNsZWFyKClgIG1ldGhvZCBpcyBjYWxsaW5nIGAkcm9vdC5yZW1vdmVSZWYocmVmSWQpYCBmb3JcbiAgICAgICAgICAgICAgICAvLyBlYWNoIGl0ZW0gaW5zaWRlIHRoaXMgY29sbGVjdGlvblxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgKHJlZiBhcyBTY2hlbWFEZWNvZGVyQ2FsbGJhY2tzKS5jbGVhcih0cnVlKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgZmllbGRJbmRleCA9IChpc1NjaGVtYSlcbiAgICAgICAgICAgICAgICA/IGJ5dGUgJSAob3BlcmF0aW9uIHx8IDI1NSkgLy8gaWYgXCJSRVBMQUNFXCIgb3BlcmF0aW9uICgwKSwgdXNlIDI1NVxuICAgICAgICAgICAgICAgIDogZGVjb2RlLm51bWJlcihieXRlcywgaXQpO1xuXG4gICAgICAgICAgICBjb25zdCBmaWVsZE5hbWUgPSAoaXNTY2hlbWEpXG4gICAgICAgICAgICAgICAgPyAocmVmWydfZGVmaW5pdGlvbiddLmZpZWxkc0J5SW5kZXhbZmllbGRJbmRleF0pXG4gICAgICAgICAgICAgICAgOiBcIlwiO1xuXG4gICAgICAgICAgICBsZXQgdHlwZSA9IGNoYW5nZVRyZWUuZ2V0VHlwZShmaWVsZEluZGV4KTtcbiAgICAgICAgICAgIGxldCB2YWx1ZTogYW55O1xuICAgICAgICAgICAgbGV0IHByZXZpb3VzVmFsdWU6IGFueTtcblxuICAgICAgICAgICAgbGV0IGR5bmFtaWNJbmRleDogbnVtYmVyIHwgc3RyaW5nO1xuXG4gICAgICAgICAgICBpZiAoIWlzU2NoZW1hKSB7XG4gICAgICAgICAgICAgICAgcHJldmlvdXNWYWx1ZSA9IHJlZlsnZ2V0QnlJbmRleCddKGZpZWxkSW5kZXgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKChvcGVyYXRpb24gJiBPUEVSQVRJT04uQUREKSA9PT0gT1BFUkFUSU9OLkFERCkgeyAvLyBBREQgb3IgREVMRVRFX0FORF9BRERcbiAgICAgICAgICAgICAgICAgICAgZHluYW1pY0luZGV4ID0gKHJlZiBpbnN0YW5jZW9mIE1hcFNjaGVtYSlcbiAgICAgICAgICAgICAgICAgICAgICAgID8gZGVjb2RlLnN0cmluZyhieXRlcywgaXQpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGZpZWxkSW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIHJlZlsnc2V0SW5kZXgnXShmaWVsZEluZGV4LCBkeW5hbWljSW5kZXgpO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaGVyZVxuICAgICAgICAgICAgICAgICAgICBkeW5hbWljSW5kZXggPSByZWZbJ2dldEluZGV4J10oZmllbGRJbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHByZXZpb3VzVmFsdWUgPSByZWZbYF8ke2ZpZWxkTmFtZX1gXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIERlbGV0ZSBvcGVyYXRpb25zXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgaWYgKChvcGVyYXRpb24gJiBPUEVSQVRJT04uREVMRVRFKSA9PT0gT1BFUkFUSU9OLkRFTEVURSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZiAob3BlcmF0aW9uICE9PSBPUEVSQVRJT04uREVMRVRFX0FORF9BREQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVmWydkZWxldGVCeUluZGV4J10oZmllbGRJbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gRmxhZyBgcmVmSWRgIGZvciBnYXJiYWdlIGNvbGxlY3Rpb24uXG4gICAgICAgICAgICAgICAgaWYgKHByZXZpb3VzVmFsdWUgJiYgcHJldmlvdXNWYWx1ZVsnJGNoYW5nZXMnXSkge1xuICAgICAgICAgICAgICAgICAgICAkcm9vdC5yZW1vdmVSZWYocHJldmlvdXNWYWx1ZVsnJGNoYW5nZXMnXS5yZWZJZCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZmllbGROYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJAY29seXNldXMvc2NoZW1hOiBkZWZpbml0aW9uIG1pc21hdGNoXCIpO1xuXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyBrZWVwIHNraXBwaW5nIG5leHQgYnl0ZXMgdW50aWwgcmVhY2hlcyBhIGtub3duIHN0cnVjdHVyZVxuICAgICAgICAgICAgICAgIC8vIGJ5IGxvY2FsIGRlY29kZXIuXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0SXRlcmF0b3I6IGRlY29kZS5JdGVyYXRvciA9IHsgb2Zmc2V0OiBpdC5vZmZzZXQgfTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoaXQub2Zmc2V0IDwgdG90YWxCeXRlcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGVjb2RlLnN3aXRjaFN0cnVjdHVyZUNoZWNrKGJ5dGVzLCBpdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHRJdGVyYXRvci5vZmZzZXQgPSBpdC5vZmZzZXQgKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCRyb290LnJlZnMuaGFzKGRlY29kZS5udW1iZXIoYnl0ZXMsIG5leHRJdGVyYXRvcikpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpdC5vZmZzZXQrKztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICAgICAgfSBlbHNlIGlmIChvcGVyYXRpb24gPT09IE9QRVJBVElPTi5ERUxFVEUpIHtcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vIEZJWE1FOiByZWZhY3RvciBtZS5cbiAgICAgICAgICAgICAgICAvLyBEb24ndCBkbyBhbnl0aGluZy5cbiAgICAgICAgICAgICAgICAvL1xuXG4gICAgICAgICAgICB9IGVsc2UgaWYgKFNjaGVtYS5pcyh0eXBlKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlZklkID0gZGVjb2RlLm51bWJlcihieXRlcywgaXQpO1xuICAgICAgICAgICAgICAgIHZhbHVlID0gJHJvb3QucmVmcy5nZXQocmVmSWQpO1xuXG4gICAgICAgICAgICAgICAgaWYgKG9wZXJhdGlvbiAhPT0gT1BFUkFUSU9OLlJFUExBQ0UpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hpbGRUeXBlID0gdGhpcy5nZXRTY2hlbWFUeXBlKGJ5dGVzLCBpdCwgdHlwZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLmNyZWF0ZVR5cGVJbnN0YW5jZShjaGlsZFR5cGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUuJGNoYW5nZXMucmVmSWQgPSByZWZJZDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByZXZpb3VzVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZS5vbkNoYW5nZSA9IHByZXZpb3VzVmFsdWUub25DaGFuZ2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUub25SZW1vdmUgPSBwcmV2aW91c1ZhbHVlLm9uUmVtb3ZlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLiRsaXN0ZW5lcnMgPSBwcmV2aW91c1ZhbHVlLiRsaXN0ZW5lcnM7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZpb3VzVmFsdWVbJyRjaGFuZ2VzJ10ucmVmSWQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmSWQgIT09IHByZXZpb3VzVmFsdWVbJyRjaGFuZ2VzJ10ucmVmSWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJHJvb3QucmVtb3ZlUmVmKHByZXZpb3VzVmFsdWVbJyRjaGFuZ2VzJ10ucmVmSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICRyb290LmFkZFJlZihyZWZJZCwgdmFsdWUsICh2YWx1ZSAhPT0gcHJldmlvdXNWYWx1ZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mKHR5cGUpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyBwcmltaXRpdmUgdmFsdWUgKG51bWJlciwgc3RyaW5nLCBib29sZWFuLCBldGMpXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGRlY29kZVByaW1pdGl2ZVR5cGUodHlwZSBhcyBzdHJpbmcsIGJ5dGVzLCBpdCk7XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZURlZiA9IGdldFR5cGUoT2JqZWN0LmtleXModHlwZSlbMF0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlZklkID0gZGVjb2RlLm51bWJlcihieXRlcywgaXQpO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWVSZWY6IFNjaGVtYURlY29kZXJDYWxsYmFja3MgPSAoJHJvb3QucmVmcy5oYXMocmVmSWQpKVxuICAgICAgICAgICAgICAgICAgICA/IHByZXZpb3VzVmFsdWVcbiAgICAgICAgICAgICAgICAgICAgOiBuZXcgdHlwZURlZi5jb25zdHJ1Y3RvcigpO1xuXG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZVJlZi5jbG9uZSh0cnVlKTtcbiAgICAgICAgICAgICAgICB2YWx1ZS4kY2hhbmdlcy5yZWZJZCA9IHJlZklkO1xuXG4gICAgICAgICAgICAgICAgLy8gcHJlc2VydmUgc2NoZW1hIGNhbGxiYWNrc1xuICAgICAgICAgICAgICAgIGlmIChwcmV2aW91c1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLm9uQWRkID0gcHJldmlvdXNWYWx1ZS5vbkFkZDtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUub25SZW1vdmUgPSBwcmV2aW91c1ZhbHVlLm9uUmVtb3ZlO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZS5vbkNoYW5nZSA9IHByZXZpb3VzVmFsdWUub25DaGFuZ2U7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJldmlvdXNWYWx1ZVsnJGNoYW5nZXMnXS5yZWZJZCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVmSWQgIT09IHByZXZpb3VzVmFsdWVbJyRjaGFuZ2VzJ10ucmVmSWRcbiAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkcm9vdC5yZW1vdmVSZWYocHJldmlvdXNWYWx1ZVsnJGNoYW5nZXMnXS5yZWZJZCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUcmlnZ2VyIG9uUmVtb3ZlIGlmIHN0cnVjdHVyZSBoYXMgYmVlbiByZXBsYWNlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkZWxldGVzOiBEYXRhQ2hhbmdlW10gPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVudHJpZXM6IEl0ZXJhYmxlSXRlcmF0b3I8W2FueSwgYW55XT4gPSBwcmV2aW91c1ZhbHVlLmVudHJpZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBpdGVyOiBJdGVyYXRvclJlc3VsdDxbYW55LCBhbnldPjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICgoaXRlciA9IGVudHJpZXMubmV4dCgpKSAmJiAhaXRlci5kb25lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgW2tleSwgdmFsdWVdID0gaXRlci52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGVzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcDogT1BFUkFUSU9OLkRFTEVURSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmllbGQ6IGtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldmlvdXNWYWx1ZTogdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGFsbENoYW5nZXMuc2V0KHByZXZpb3VzVmFsdWVbJyRjaGFuZ2VzJ10ucmVmSWQsIGRlbGV0ZXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgJHJvb3QuYWRkUmVmKHJlZklkLCB2YWx1ZSwgKHZhbHVlUmVmICE9PSBwcmV2aW91c1ZhbHVlKSk7XG5cbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IGRlcHJlY2F0ZSBwcm94aWVzIG9uIG5leHQgdmVyc2lvbi5cbiAgICAgICAgICAgICAgICAvLyBnZXQgcHJveHkgdG8gdGFyZ2V0IHZhbHVlLlxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVEZWYuZ2V0UHJveHkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB0eXBlRGVmLmdldFByb3h5KHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCBoYXNDaGFuZ2UgPSAocHJldmlvdXNWYWx1ZSAhPT0gdmFsdWUpO1xuXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgdmFsdWUgIT09IG51bGwgJiZcbiAgICAgICAgICAgICAgICB2YWx1ZSAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWVbJyRjaGFuZ2VzJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVbJyRjaGFuZ2VzJ10uc2V0UGFyZW50KFxuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlVHJlZS5yZWYsXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2VUcmVlLnJvb3QsXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWVsZEluZGV4LFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChyZWYgaW5zdGFuY2VvZiBTY2hlbWEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVmW2ZpZWxkTmFtZV0gPSB2YWx1ZTtcblxuICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAvLyBGSVhNRTogdXNlIGBfZmllbGRgIGluc3RlYWQgb2YgYGZpZWxkYC5cbiAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgLy8gYGZpZWxkYCBpcyBnb2luZyB0byB1c2UgdGhlIHNldHRlciBvZiB0aGUgUHJvcGVydHlEZXNjcmlwdG9yXG4gICAgICAgICAgICAgICAgICAgIC8vIGFuZCBjcmVhdGUgYSBwcm94eSBmb3IgYXJyYXkvbWFwLiBUaGlzIGlzIG9ubHkgdXNlZnVsIGZvclxuICAgICAgICAgICAgICAgICAgICAvLyBiYWNrd2FyZHMtY29tcGF0aWJpbGl0eSB3aXRoIEBjb2x5c2V1cy9zY2hlbWFAMC41LnhcbiAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgLy8gLy8gcmVmW19maWVsZF0gPSB2YWx1ZTtcblxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocmVmIGluc3RhbmNlb2YgTWFwU2NoZW1hKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnN0IGtleSA9IHJlZlsnJGluZGV4ZXMnXS5nZXQoZmllbGQpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBkeW5hbWljSW5kZXggYXMgc3RyaW5nO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIHJlZi5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHJlZlsnJGl0ZW1zJ10uc2V0KGtleSwgdmFsdWUpO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChyZWYgaW5zdGFuY2VvZiBBcnJheVNjaGVtYSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBjb25zdCBrZXkgPSByZWZbJyRpbmRleGVzJ11bZmllbGRdO1xuICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcIlNFVFRJTkcgRk9SIEFycmF5U2NoZW1hID0+XCIsIHsgZmllbGQsIGtleSwgdmFsdWUgfSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHJlZltrZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHJlZi5zZXRBdChmaWVsZEluZGV4LCB2YWx1ZSk7XG5cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgICAgICAgICByZWYgaW5zdGFuY2VvZiBDb2xsZWN0aW9uU2NoZW1hIHx8XG4gICAgICAgICAgICAgICAgICAgIHJlZiBpbnN0YW5jZW9mIFNldFNjaGVtYVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IHJlZi5hZGQodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICByZWZbJ3NldEluZGV4J10oZmllbGRJbmRleCwgaW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIGhhc0NoYW5nZVxuICAgICAgICAgICAgICAgIC8vICYmXG4gICAgICAgICAgICAgICAgLy8gKFxuICAgICAgICAgICAgICAgIC8vICAgICB0aGlzLm9uQ2hhbmdlIHx8IHJlZi4kbGlzdGVuZXJzW2ZpZWxkXVxuICAgICAgICAgICAgICAgIC8vIClcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGNoYW5nZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIG9wOiBvcGVyYXRpb24sXG4gICAgICAgICAgICAgICAgICAgIGZpZWxkOiBmaWVsZE5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGR5bmFtaWNJbmRleCxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIHByZXZpb3VzVmFsdWUsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl90cmlnZ2VyQ2hhbmdlcyhhbGxDaGFuZ2VzKTtcblxuICAgICAgICAvLyBkcm9wIHJlZmVyZW5jZXMgb2YgdW51c2VkIHNjaGVtYXNcbiAgICAgICAgJHJvb3QuZ2FyYmFnZUNvbGxlY3REZWxldGVkUmVmcygpO1xuXG4gICAgICAgIHJldHVybiBhbGxDaGFuZ2VzO1xuICAgIH1cblxuICAgIGVuY29kZShcbiAgICAgICAgZW5jb2RlQWxsID0gZmFsc2UsXG4gICAgICAgIGJ5dGVzOiBudW1iZXJbXSA9IFtdLFxuICAgICAgICB1c2VGaWx0ZXJzOiBib29sZWFuID0gZmFsc2UsXG4gICAgKSB7XG4gICAgICAgIGNvbnN0IHJvb3RDaGFuZ2VUcmVlID0gdGhpcy4kY2hhbmdlcztcbiAgICAgICAgY29uc3QgcmVmSWRzVmlzaXRlZCA9IG5ldyBXZWFrU2V0PENoYW5nZVRyZWU+KCk7XG5cbiAgICAgICAgY29uc3QgY2hhbmdlVHJlZXM6IENoYW5nZVRyZWVbXSA9IFtyb290Q2hhbmdlVHJlZV07XG4gICAgICAgIGxldCBudW1DaGFuZ2VUcmVlcyA9IDE7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1DaGFuZ2VUcmVlczsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBjaGFuZ2VUcmVlID0gY2hhbmdlVHJlZXNbaV07XG4gICAgICAgICAgICBjb25zdCByZWYgPSBjaGFuZ2VUcmVlLnJlZjtcbiAgICAgICAgICAgIGNvbnN0IGlzU2NoZW1hID0gKHJlZiBpbnN0YW5jZW9mIFNjaGVtYSk7XG5cbiAgICAgICAgICAgIC8vIEdlbmVyYXRlIHVuaXF1ZSByZWZJZCBmb3IgdGhlIENoYW5nZVRyZWUuXG4gICAgICAgICAgICBjaGFuZ2VUcmVlLmVuc3VyZVJlZklkKCk7XG5cbiAgICAgICAgICAgIC8vIG1hcmsgdGhpcyBDaGFuZ2VUcmVlIGFzIHZpc2l0ZWQuXG4gICAgICAgICAgICByZWZJZHNWaXNpdGVkLmFkZChjaGFuZ2VUcmVlKTtcblxuICAgICAgICAgICAgLy8gcm9vdCBgcmVmSWRgIGlzIHNraXBwZWQuXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgY2hhbmdlVHJlZSAhPT0gcm9vdENoYW5nZVRyZWUgJiZcbiAgICAgICAgICAgICAgICAoY2hhbmdlVHJlZS5jaGFuZ2VkIHx8IGVuY29kZUFsbClcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGVuY29kZS51aW50OChieXRlcywgU1dJVENIX1RPX1NUUlVDVFVSRSk7XG4gICAgICAgICAgICAgICAgZW5jb2RlLm51bWJlcihieXRlcywgY2hhbmdlVHJlZS5yZWZJZCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGNoYW5nZXM6IENoYW5nZU9wZXJhdGlvbltdIHwgbnVtYmVyW10gPSAoZW5jb2RlQWxsKVxuICAgICAgICAgICAgICAgID8gQXJyYXkuZnJvbShjaGFuZ2VUcmVlLmFsbENoYW5nZXMpXG4gICAgICAgICAgICAgICAgOiBBcnJheS5mcm9tKGNoYW5nZVRyZWUuY2hhbmdlcy52YWx1ZXMoKSk7XG5cbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwLCBjbCA9IGNoYW5nZXMubGVuZ3RoOyBqIDwgY2w7IGorKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9wZXJhdGlvbjogQ2hhbmdlT3BlcmF0aW9uID0gKGVuY29kZUFsbClcbiAgICAgICAgICAgICAgICAgICAgPyB7IG9wOiBPUEVSQVRJT04uQURELCBpbmRleDogY2hhbmdlc1tqXSBhcyBudW1iZXIgfVxuICAgICAgICAgICAgICAgICAgICA6IGNoYW5nZXNbal0gYXMgQ2hhbmdlT3BlcmF0aW9uO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgZmllbGRJbmRleCA9IG9wZXJhdGlvbi5pbmRleDtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGZpZWxkID0gKGlzU2NoZW1hKVxuICAgICAgICAgICAgICAgICAgICA/IHJlZlsnX2RlZmluaXRpb24nXS5maWVsZHNCeUluZGV4ICYmIHJlZlsnX2RlZmluaXRpb24nXS5maWVsZHNCeUluZGV4W2ZpZWxkSW5kZXhdXG4gICAgICAgICAgICAgICAgICAgIDogZmllbGRJbmRleDtcblxuICAgICAgICAgICAgICAgIC8vIGNhY2hlIGJlZ2luIGluZGV4IGlmIGB1c2VGaWx0ZXJzYFxuICAgICAgICAgICAgICAgIGNvbnN0IGJlZ2luSW5kZXggPSBieXRlcy5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICAvLyBlbmNvZGUgZmllbGQgaW5kZXggKyBvcGVyYXRpb25cbiAgICAgICAgICAgICAgICBpZiAob3BlcmF0aW9uLm9wICE9PSBPUEVSQVRJT04uVE9VQ0gpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzU2NoZW1hKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29tcHJlc3MgYGZpZWxkSW5kZXhgICsgYG9wZXJhdGlvbmAgaW50byBhIHNpbmdsZSBieXRlLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBhZGRzIGEgbGltaXRhaW9uIG9mIDY0IGZpZWxkcyBwZXIgU2NoZW1hIHN0cnVjdHVyZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgICAgIGVuY29kZS51aW50OChieXRlcywgKGZpZWxkSW5kZXggfCBvcGVyYXRpb24ub3ApKTtcblxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW5jb2RlLnVpbnQ4KGJ5dGVzLCBvcGVyYXRpb24ub3ApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjdXN0b20gb3BlcmF0aW9uc1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wZXJhdGlvbi5vcCA9PT0gT1BFUkFUSU9OLkNMRUFSKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGluZGV4ZWQgb3BlcmF0aW9uc1xuICAgICAgICAgICAgICAgICAgICAgICAgZW5jb2RlLm51bWJlcihieXRlcywgZmllbGRJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vIGVuY29kZSBcImFsaWFzXCIgZm9yIGR5bmFtaWMgZmllbGRzIChtYXBzKVxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAhaXNTY2hlbWEgJiZcbiAgICAgICAgICAgICAgICAgICAgKG9wZXJhdGlvbi5vcCAmIE9QRVJBVElPTi5BREQpID09IE9QRVJBVElPTi5BREQgLy8gQUREIG9yIERFTEVURV9BTkRfQUREXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWYgaW5zdGFuY2VvZiBNYXBTY2hlbWEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBNYXBTY2hlbWEgZHluYW1pYyBrZXlcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkeW5hbWljSW5kZXggPSBjaGFuZ2VUcmVlLnJlZlsnJGluZGV4ZXMnXS5nZXQoZmllbGRJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbmNvZGUuc3RyaW5nKGJ5dGVzLCBkeW5hbWljSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKG9wZXJhdGlvbi5vcCA9PT0gT1BFUkFUSU9OLkRFTEVURSkge1xuICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBkZWxldGUgZnJvbSBmaWx0ZXIgY2FjaGUgZGF0YS5cbiAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgKHVzZUZpbHRlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgIGRlbGV0ZSBjaGFuZ2VUcmVlLmNhY2hlc1tmaWVsZEluZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBjb25zdCB0eXBlID0gY2hhbmdlVHJlZS5jaGlsZFR5cGUgfHwgcmVmLl9zY2hlbWFbZmllbGRdO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGUgPSBjaGFuZ2VUcmVlLmdldFR5cGUoZmllbGRJbmRleCk7XG5cbiAgICAgICAgICAgICAgICAvLyBjb25zdCB0eXBlID0gY2hhbmdlVHJlZS5nZXRUeXBlKGZpZWxkSW5kZXgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gY2hhbmdlVHJlZS5nZXRWYWx1ZShmaWVsZEluZGV4KTtcblxuICAgICAgICAgICAgICAgIC8vIEVucXVldWUgQ2hhbmdlVHJlZSB0byBiZSB2aXNpdGVkXG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSAmJlxuICAgICAgICAgICAgICAgICAgICB2YWx1ZVsnJGNoYW5nZXMnXSAmJlxuICAgICAgICAgICAgICAgICAgICAhcmVmSWRzVmlzaXRlZC5oYXModmFsdWVbJyRjaGFuZ2VzJ10pXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZVRyZWVzLnB1c2godmFsdWVbJyRjaGFuZ2VzJ10pO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZVsnJGNoYW5nZXMnXS5lbnN1cmVSZWZJZCgpO1xuICAgICAgICAgICAgICAgICAgICBudW1DaGFuZ2VUcmVlcysrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChvcGVyYXRpb24ub3AgPT09IE9QRVJBVElPTi5UT1VDSCkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoU2NoZW1hLmlzKHR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGFzc2VydEluc3RhbmNlVHlwZSh2YWx1ZSwgdHlwZSBhcyB0eXBlb2YgU2NoZW1hLCByZWYgYXMgU2NoZW1hLCBmaWVsZCk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgLy8gRW5jb2RlIHJlZklkIGZvciB0aGlzIGluc3RhbmNlLlxuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgYWN0dWFsIGluc3RhbmNlIGlzIGdvaW5nIHRvIGJlIGVuY29kZWQgb24gbmV4dCBgY2hhbmdlVHJlZWAgaXRlcmF0aW9uLlxuICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICBlbmNvZGUubnVtYmVyKGJ5dGVzLCB2YWx1ZS4kY2hhbmdlcy5yZWZJZCk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gVHJ5IHRvIGVuY29kZSBpbmhlcml0ZWQgVFlQRV9JRCBpZiBpdCdzIGFuIEFERCBvcGVyYXRpb24uXG4gICAgICAgICAgICAgICAgICAgIGlmICgob3BlcmF0aW9uLm9wICYgT1BFUkFUSU9OLkFERCkgPT09IE9QRVJBVElPTi5BREQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudHJ5RW5jb2RlVHlwZUlkKGJ5dGVzLCB0eXBlIGFzIHR5cGVvZiBTY2hlbWEsIHZhbHVlLmNvbnN0cnVjdG9yIGFzIHR5cGVvZiBTY2hlbWEpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZih0eXBlKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAvLyBQcmltaXRpdmUgdmFsdWVzXG4gICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgIGVuY29kZVByaW1pdGl2ZVR5cGUodHlwZSBhcyBQcmltaXRpdmVUeXBlLCBieXRlcywgdmFsdWUsIHJlZiBhcyBTY2hlbWEsIGZpZWxkKTtcblxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgIC8vIEN1c3RvbSB0eXBlIChNYXBTY2hlbWEsIEFycmF5U2NoZW1hLCBldGMpXG4gICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRlZmluaXRpb24gPSBnZXRUeXBlKE9iamVjdC5rZXlzKHR5cGUpWzBdKTtcblxuICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAvLyBlbnN1cmUgYSBBcnJheVNjaGVtYSBoYXMgYmVlbiBwcm92aWRlZFxuICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICBhc3NlcnRJbnN0YW5jZVR5cGUocmVmW2BfJHtmaWVsZH1gXSwgZGVmaW5pdGlvbi5jb25zdHJ1Y3RvciwgcmVmIGFzIFNjaGVtYSwgZmllbGQpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgIC8vIEVuY29kZSByZWZJZCBmb3IgdGhpcyBpbnN0YW5jZS5cbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGFjdHVhbCBpbnN0YW5jZSBpcyBnb2luZyB0byBiZSBlbmNvZGVkIG9uIG5leHQgYGNoYW5nZVRyZWVgIGl0ZXJhdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgZW5jb2RlLm51bWJlcihieXRlcywgdmFsdWUuJGNoYW5nZXMucmVmSWQpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh1c2VGaWx0ZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNhY2hlIGJlZ2luIC8gZW5kIGluZGV4XG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZVRyZWUuY2FjaGUoZmllbGRJbmRleCBhcyBudW1iZXIsIGJ5dGVzLnNsaWNlKGJlZ2luSW5kZXgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghZW5jb2RlQWxsICYmICF1c2VGaWx0ZXJzKSB7XG4gICAgICAgICAgICAgICAgY2hhbmdlVHJlZS5kaXNjYXJkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYnl0ZXM7XG4gICAgfVxuXG4gICAgZW5jb2RlQWxsICh1c2VGaWx0ZXJzPzogYm9vbGVhbikge1xuICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGUodHJ1ZSwgW10sIHVzZUZpbHRlcnMpO1xuICAgIH1cblxuICAgIGFwcGx5RmlsdGVycyhjbGllbnQ6IENsaWVudCwgZW5jb2RlQWxsOiBib29sZWFuID0gZmFsc2UpIHtcbiAgICAgICAgY29uc3Qgcm9vdCA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHJlZklkc0Rpc3NhbGxvd2VkID0gbmV3IFNldDxudW1iZXI+KCk7XG5cbiAgICAgICAgY29uc3QgJGZpbHRlclN0YXRlID0gQ2xpZW50U3RhdGUuZ2V0KGNsaWVudCk7XG5cbiAgICAgICAgY29uc3QgY2hhbmdlVHJlZXMgPSBbdGhpcy4kY2hhbmdlc107XG4gICAgICAgIGxldCBudW1DaGFuZ2VUcmVlcyA9IDE7XG5cbiAgICAgICAgbGV0IGZpbHRlcmVkQnl0ZXM6IG51bWJlcltdID0gW107XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1DaGFuZ2VUcmVlczsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBjaGFuZ2VUcmVlID0gY2hhbmdlVHJlZXNbaV07XG5cbiAgICAgICAgICAgIGlmIChyZWZJZHNEaXNzYWxsb3dlZC5oYXMoY2hhbmdlVHJlZS5yZWZJZCkpICB7XG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coXCJSRUZJRCBJUyBOT1QgQUxMT1dFRC4gU0tJUC5cIiwgeyByZWZJZDogY2hhbmdlVHJlZS5yZWZJZCB9KVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCByZWYgPSBjaGFuZ2VUcmVlLnJlZiBhcyBSZWY7XG4gICAgICAgICAgICBjb25zdCBpc1NjaGVtYTogYm9vbGVhbiA9IHJlZiBpbnN0YW5jZW9mIFNjaGVtYTtcblxuICAgICAgICAgICAgZW5jb2RlLnVpbnQ4KGZpbHRlcmVkQnl0ZXMsIFNXSVRDSF9UT19TVFJVQ1RVUkUpO1xuICAgICAgICAgICAgZW5jb2RlLm51bWJlcihmaWx0ZXJlZEJ5dGVzLCBjaGFuZ2VUcmVlLnJlZklkKTtcblxuICAgICAgICAgICAgY29uc3QgY2xpZW50SGFzUmVmSWQgPSAkZmlsdGVyU3RhdGUucmVmSWRzLmhhcyhjaGFuZ2VUcmVlKTtcbiAgICAgICAgICAgIGNvbnN0IGlzRW5jb2RlQWxsID0gKGVuY29kZUFsbCB8fCAhY2xpZW50SGFzUmVmSWQpO1xuXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcIlJFRjpcIiwgcmVmLmNvbnN0cnVjdG9yLm5hbWUpO1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coXCJFbmNvZGUgYWxsP1wiLCBpc0VuY29kZUFsbCk7XG5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBpbmNsdWRlIGBjaGFuZ2VUcmVlYCBvbiBsaXN0IG9mIGtub3duIHJlZklkcyBieSB0aGlzIGNsaWVudC5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAkZmlsdGVyU3RhdGUuYWRkUmVmSWQoY2hhbmdlVHJlZSk7XG5cbiAgICAgICAgICAgIGNvbnN0IGNvbnRhaW5lckluZGV4ZXMgPSAkZmlsdGVyU3RhdGUuY29udGFpbmVySW5kZXhlcy5nZXQoY2hhbmdlVHJlZSlcbiAgICAgICAgICAgIGNvbnN0IGNoYW5nZXMgPSAoaXNFbmNvZGVBbGwpXG4gICAgICAgICAgICAgICAgPyBBcnJheS5mcm9tKGNoYW5nZVRyZWUuYWxsQ2hhbmdlcylcbiAgICAgICAgICAgICAgICA6IEFycmF5LmZyb20oY2hhbmdlVHJlZS5jaGFuZ2VzLnZhbHVlcygpKTtcblxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIFdPUktBUk9VTkQ6IHRyaWVzIHRvIHJlLWV2YWx1YXRlIHByZXZpb3VzbHkgbm90IGluY2x1ZGVkIEBmaWx0ZXIoKSBhdHRyaWJ1dGVzXG4gICAgICAgICAgICAvLyAtIHNlZSBcIkRFTEVURSBhIGZpZWxkIG9mIFNjaGVtYVwiIHRlc3QgY2FzZS5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgIWVuY29kZUFsbCAmJlxuICAgICAgICAgICAgICAgIGlzU2NoZW1hICYmXG4gICAgICAgICAgICAgICAgKHJlZiBhcyBTY2hlbWEpLl9kZWZpbml0aW9uLmluZGV4ZXNXaXRoRmlsdGVyc1xuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5kZXhlc1dpdGhGaWx0ZXJzID0gKHJlZiBhcyBTY2hlbWEpLl9kZWZpbml0aW9uLmluZGV4ZXNXaXRoRmlsdGVycztcbiAgICAgICAgICAgICAgICBpbmRleGVzV2l0aEZpbHRlcnMuZm9yRWFjaChpbmRleFdpdGhGaWx0ZXIgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAhY29udGFpbmVySW5kZXhlcy5oYXMoaW5kZXhXaXRoRmlsdGVyKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlVHJlZS5hbGxDaGFuZ2VzLmhhcyhpbmRleFdpdGhGaWx0ZXIpXG4gICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzRW5jb2RlQWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlcy5wdXNoKGluZGV4V2l0aEZpbHRlciBhcyBhbnkpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZXMucHVzaCh7IG9wOiBPUEVSQVRJT04uQURELCBpbmRleDogaW5kZXhXaXRoRmlsdGVyLCB9IGFzIGFueSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDAsIGNsID0gY2hhbmdlcy5sZW5ndGg7IGogPCBjbDsgaisrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2hhbmdlOiBDaGFuZ2VPcGVyYXRpb24gPSAoaXNFbmNvZGVBbGwpXG4gICAgICAgICAgICAgICAgICAgID8geyBvcDogT1BFUkFUSU9OLkFERCwgaW5kZXg6IGNoYW5nZXNbal0gYXMgbnVtYmVyIH1cbiAgICAgICAgICAgICAgICAgICAgOiBjaGFuZ2VzW2pdIGFzIENoYW5nZU9wZXJhdGlvbjtcblxuICAgICAgICAgICAgICAgIC8vIGN1c3RvbSBvcGVyYXRpb25zXG4gICAgICAgICAgICAgICAgaWYgKGNoYW5nZS5vcCA9PT0gT1BFUkFUSU9OLkNMRUFSKSB7XG4gICAgICAgICAgICAgICAgICAgIGVuY29kZS51aW50OChmaWx0ZXJlZEJ5dGVzLCBjaGFuZ2Uub3ApO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb25zdCBmaWVsZEluZGV4ID0gY2hhbmdlLmluZGV4O1xuXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyBEZWxldGluZyBmaWVsZHM6IGVuY29kZSB0aGUgb3BlcmF0aW9uICsgZmllbGQgaW5kZXhcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIGlmIChjaGFuZ2Uub3AgPT09IE9QRVJBVElPTi5ERUxFVEUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgLy8gREVMRVRFIG9wZXJhdGlvbnMgYWxzbyBuZWVkIHRvIGdvIHRocm91Z2ggZmlsdGVyaW5nLlxuICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBjYWNoZSB0aGUgcHJldmlvdXMgdmFsdWUgc28gd2UgY2FuIGFjY2VzcyB0aGUgdmFsdWUgKHByaW1pdGl2ZSBvciBgcmVmSWRgKVxuICAgICAgICAgICAgICAgICAgICAvLyAoY2hlY2sgYWdhaW5zdCBgJGZpbHRlclN0YXRlLnJlZklkc2ApXG4gICAgICAgICAgICAgICAgICAgIC8vXG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzU2NoZW1hKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbmNvZGUudWludDgoZmlsdGVyZWRCeXRlcywgY2hhbmdlLm9wIHwgZmllbGRJbmRleCk7XG5cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuY29kZS51aW50OChmaWx0ZXJlZEJ5dGVzLCBjaGFuZ2Uub3ApO1xuICAgICAgICAgICAgICAgICAgICAgICAgZW5jb2RlLm51bWJlcihmaWx0ZXJlZEJ5dGVzLCBmaWVsZEluZGV4KTtcblxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGluZGV4ZWQgb3BlcmF0aW9uXG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBjaGFuZ2VUcmVlLmdldFZhbHVlKGZpZWxkSW5kZXgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGUgPSBjaGFuZ2VUcmVlLmdldFR5cGUoZmllbGRJbmRleCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoaXNTY2hlbWEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSXMgYSBTY2hlbWEhXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpbHRlciA9IChcbiAgICAgICAgICAgICAgICAgICAgICAgIChyZWYgYXMgU2NoZW1hKS5fZGVmaW5pdGlvbi5maWx0ZXJzICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAocmVmIGFzIFNjaGVtYSkuX2RlZmluaXRpb24uZmlsdGVyc1tmaWVsZEluZGV4XVxuICAgICAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChmaWx0ZXIgJiYgIWZpbHRlci5jYWxsKHJlZiwgY2xpZW50LCB2YWx1ZSwgcm9vdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAmJiB2YWx1ZVsnJGNoYW5nZXMnXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZklkc0Rpc3NhbGxvd2VkLmFkZCh2YWx1ZVsnJGNoYW5nZXMnXS5yZWZJZCk7O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElzIGEgY29sbGVjdGlvbiEgKG1hcCwgYXJyYXksIGV0Yy4pXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcmVudCA9IGNoYW5nZVRyZWUucGFyZW50IGFzIFJlZjtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZmlsdGVyID0gY2hhbmdlVHJlZS5nZXRDaGlsZHJlbkZpbHRlcigpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChmaWx0ZXIgJiYgIWZpbHRlci5jYWxsKHBhcmVudCwgY2xpZW50LCByZWZbJyRpbmRleGVzJ10uZ2V0KGZpZWxkSW5kZXgpLCB2YWx1ZSwgcm9vdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAmJiB2YWx1ZVsnJGNoYW5nZXMnXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZklkc0Rpc3NhbGxvd2VkLmFkZCh2YWx1ZVsnJGNoYW5nZXMnXS5yZWZJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIHZpc2l0IGNoaWxkIENoYW5nZVRyZWUgb24gZnVydGhlciBpdGVyYXRpb24uXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlWyckY2hhbmdlcyddKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZVRyZWVzLnB1c2godmFsdWVbJyRjaGFuZ2VzJ10pO1xuICAgICAgICAgICAgICAgICAgICBudW1DaGFuZ2VUcmVlcysrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gQ29weSBjYWNoZWQgYnl0ZXNcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIGlmIChjaGFuZ2Uub3AgIT09IE9QRVJBVElPTi5UT1VDSCkge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IHJlZmFjdG9yIG1lIVxuICAgICAgICAgICAgICAgICAgICAvL1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGFuZ2Uub3AgPT09IE9QRVJBVElPTi5BREQgfHwgaXNTY2hlbWEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB1c2UgY2FjaGVkIGJ5dGVzIGRpcmVjdGx5IGlmIGlzIGZyb20gU2NoZW1hIHR5cGUuXG4gICAgICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlsdGVyZWRCeXRlcyA9IGZpbHRlcmVkQnl0ZXMuY29uY2F0KGNoYW5nZVRyZWUuY2FjaGVzW2ZpZWxkSW5kZXhdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lckluZGV4ZXMuYWRkKGZpZWxkSW5kZXgpO1xuXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udGFpbmVySW5kZXhlcy5oYXMoZmllbGRJbmRleCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHVzZSBjYWNoZWQgYnl0ZXMgaWYgYWxyZWFkeSBoYXMgdGhlIGZpZWxkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWx0ZXJlZEJ5dGVzID0gZmlsdGVyZWRCeXRlcy5jb25jYXQoY2hhbmdlVHJlZS5jYWNoZXNbZmllbGRJbmRleF0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZm9yY2UgQUREIG9wZXJhdGlvbiBpZiBmaWVsZCBpcyBub3Qga25vd24gYnkgdGhpcyBjbGllbnQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250YWluZXJJbmRleGVzLmFkZChmaWVsZEluZGV4KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuY29kZS51aW50OChmaWx0ZXJlZEJ5dGVzLCBPUEVSQVRJT04uQUREKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmNvZGUubnVtYmVyKGZpbHRlcmVkQnl0ZXMsIGZpZWxkSW5kZXgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlZiBpbnN0YW5jZW9mIE1hcFNjaGVtYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBNYXBTY2hlbWEgZHluYW1pYyBrZXlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZHluYW1pY0luZGV4ID0gY2hhbmdlVHJlZS5yZWZbJyRpbmRleGVzJ10uZ2V0KGZpZWxkSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmNvZGUuc3RyaW5nKGZpbHRlcmVkQnl0ZXMsIGR5bmFtaWNJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlWyckY2hhbmdlcyddKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuY29kZS5udW1iZXIoZmlsdGVyZWRCeXRlcywgdmFsdWVbJyRjaGFuZ2VzJ10ucmVmSWQpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gXCJlbmNvZGVQcmltaXRpdmVUeXBlXCIgd2l0aG91dCB0eXBlIGNoZWNraW5nLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgdHlwZSBjaGVja2luZyBoYXMgYmVlbiBkb25lIG9uIHRoZSBmaXJzdCAuZW5jb2RlKCkgY2FsbC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5jb2RlW3R5cGUgYXMgc3RyaW5nXShmaWx0ZXJlZEJ5dGVzLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlWyckY2hhbmdlcyddICYmICFpc1NjaGVtYSkge1xuICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOlxuICAgICAgICAgICAgICAgICAgICAvLyAtIHRyYWNrIEFERC9SRVBMQUNFL0RFTEVURSBpbnN0YW5jZXMgb24gYCRmaWx0ZXJTdGF0ZWBcbiAgICAgICAgICAgICAgICAgICAgLy8gLSBkbyBOT1QgYWx3YXlzIGVuY29kZSBkeW5hbWljSW5kZXggZm9yIE1hcFNjaGVtYS5cbiAgICAgICAgICAgICAgICAgICAgLy8gICAoSWYgY2xpZW50IGFscmVhZHkgaGFzIHRoYXQga2V5LCBvbmx5IHRoZSBmaXJzdCBpbmRleCBpcyBuZWNlc3NhcnkuKVxuICAgICAgICAgICAgICAgICAgICAvL1xuXG4gICAgICAgICAgICAgICAgICAgIGVuY29kZS51aW50OChmaWx0ZXJlZEJ5dGVzLCBPUEVSQVRJT04uQUREKTtcbiAgICAgICAgICAgICAgICAgICAgZW5jb2RlLm51bWJlcihmaWx0ZXJlZEJ5dGVzLCBmaWVsZEluZGV4KTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAocmVmIGluc3RhbmNlb2YgTWFwU2NoZW1hKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWFwU2NoZW1hIGR5bmFtaWMga2V5XG4gICAgICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZHluYW1pY0luZGV4ID0gY2hhbmdlVHJlZS5yZWZbJyRpbmRleGVzJ10uZ2V0KGZpZWxkSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZW5jb2RlLnN0cmluZyhmaWx0ZXJlZEJ5dGVzLCBkeW5hbWljSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZW5jb2RlLm51bWJlcihmaWx0ZXJlZEJ5dGVzLCB2YWx1ZVsnJGNoYW5nZXMnXS5yZWZJZCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZpbHRlcmVkQnl0ZXM7XG4gICAgfVxuXG4gICAgY2xvbmUgKCk6IHRoaXMge1xuICAgICAgICBjb25zdCBjbG9uZWQgPSBuZXcgKCh0aGlzIGFzIGFueSkuY29uc3RydWN0b3IpO1xuICAgICAgICBjb25zdCBzY2hlbWEgPSB0aGlzLl9kZWZpbml0aW9uLnNjaGVtYTtcbiAgICAgICAgZm9yIChsZXQgZmllbGQgaW4gc2NoZW1hKSB7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgdHlwZW9mICh0aGlzW2ZpZWxkXSkgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgKHRoaXNbZmllbGRdLmNsb25lKSA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAvLyBkZWVwIGNsb25lXG4gICAgICAgICAgICAgICAgY2xvbmVkW2ZpZWxkXSA9IHRoaXNbZmllbGRdLmNsb25lKCk7XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gcHJpbWl0aXZlIHZhbHVlc1xuICAgICAgICAgICAgICAgIGNsb25lZFtmaWVsZF0gPSB0aGlzW2ZpZWxkXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2xvbmVkO1xuICAgIH1cblxuICAgIHRyaWdnZXJBbGwoKSB7XG4gICAgICAgIC8vIHNraXAgaWYgaGF2ZW4ndCByZWNlaXZlZCBhbnkgcmVtb3RlIHJlZnMgeWV0LlxuICAgICAgICBpZiAodGhpcy4kY2hhbmdlcy5yb290LnJlZnMuc2l6ZSA9PT0gMCkgeyByZXR1cm47IH1cblxuICAgICAgICBjb25zdCBhbGxDaGFuZ2VzID0gbmV3IE1hcDxudW1iZXIsIERhdGFDaGFuZ2VbXT4oKTtcbiAgICAgICAgU2NoZW1hLnByb3RvdHlwZS5fdHJpZ2dlckFsbEZpbGxDaGFuZ2VzLmNhbGwodGhpcywgdGhpcywgYWxsQ2hhbmdlcyk7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIFNjaGVtYS5wcm90b3R5cGUuX3RyaWdnZXJDaGFuZ2VzLmNhbGwodGhpcywgYWxsQ2hhbmdlcyk7XG5cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgU2NoZW1hLm9uRXJyb3IoZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0b0pTT04gKCkge1xuICAgICAgICBjb25zdCBzY2hlbWEgPSB0aGlzLl9kZWZpbml0aW9uLnNjaGVtYTtcbiAgICAgICAgY29uc3QgZGVwcmVjYXRlZCA9IHRoaXMuX2RlZmluaXRpb24uZGVwcmVjYXRlZDtcblxuICAgICAgICBjb25zdCBvYmogPSB7fVxuICAgICAgICBmb3IgKGxldCBmaWVsZCBpbiBzY2hlbWEpIHtcbiAgICAgICAgICAgIGlmICghZGVwcmVjYXRlZFtmaWVsZF0gJiYgdGhpc1tmaWVsZF0gIT09IG51bGwgJiYgdHlwZW9mICh0aGlzW2ZpZWxkXSkgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICBvYmpbZmllbGRdID0gKHR5cGVvZiAodGhpc1tmaWVsZF1bJ3RvSlNPTiddKSA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgICAgICAgICAgICA/IHRoaXNbZmllbGRdWyd0b0pTT04nXSgpXG4gICAgICAgICAgICAgICAgICAgIDogdGhpc1tgXyR7ZmllbGR9YF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBkaXNjYXJkQWxsQ2hhbmdlcygpIHtcbiAgICAgICAgdGhpcy4kY2hhbmdlcy5kaXNjYXJkQWxsKCk7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIGdldEJ5SW5kZXgoaW5kZXg6IG51bWJlcikge1xuICAgICAgICByZXR1cm4gdGhpc1t0aGlzLl9kZWZpbml0aW9uLmZpZWxkc0J5SW5kZXhbaW5kZXhdXTtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgZGVsZXRlQnlJbmRleChpbmRleDogbnVtYmVyKSB7XG4gICAgICAgIHRoaXNbdGhpcy5fZGVmaW5pdGlvbi5maWVsZHNCeUluZGV4W2luZGV4XV0gPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSB0cnlFbmNvZGVUeXBlSWQgKGJ5dGVzOiBudW1iZXJbXSwgdHlwZTogdHlwZW9mIFNjaGVtYSwgdGFyZ2V0VHlwZTogdHlwZW9mIFNjaGVtYSkge1xuICAgICAgICBpZiAodHlwZS5fdHlwZWlkICE9PSB0YXJnZXRUeXBlLl90eXBlaWQpIHtcbiAgICAgICAgICAgIGVuY29kZS51aW50OChieXRlcywgVFlQRV9JRCk7XG4gICAgICAgICAgICBlbmNvZGUubnVtYmVyKGJ5dGVzLCB0YXJnZXRUeXBlLl90eXBlaWQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRTY2hlbWFUeXBlKGJ5dGVzOiBudW1iZXJbXSwgaXQ6IGRlY29kZS5JdGVyYXRvciwgZGVmYXVsdFR5cGU6IHR5cGVvZiBTY2hlbWEpOiB0eXBlb2YgU2NoZW1hIHtcbiAgICAgICAgbGV0IHR5cGU6IHR5cGVvZiBTY2hlbWE7XG5cbiAgICAgICAgaWYgKGJ5dGVzW2l0Lm9mZnNldF0gPT09IFRZUEVfSUQpIHtcbiAgICAgICAgICAgIGl0Lm9mZnNldCsrO1xuICAgICAgICAgICAgdHlwZSA9ICh0aGlzLmNvbnN0cnVjdG9yIGFzIHR5cGVvZiBTY2hlbWEpLl9jb250ZXh0LmdldChkZWNvZGUubnVtYmVyKGJ5dGVzLCBpdCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHR5cGUgfHwgZGVmYXVsdFR5cGU7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBjcmVhdGVUeXBlSW5zdGFuY2UgKHR5cGU6IHR5cGVvZiBTY2hlbWEpOiBTY2hlbWEge1xuICAgICAgICBsZXQgaW5zdGFuY2U6IFNjaGVtYSA9IG5ldyAodHlwZSBhcyBhbnkpKCk7XG5cbiAgICAgICAgLy8gYXNzaWduIHJvb3Qgb24gJGNoYW5nZXNcbiAgICAgICAgaW5zdGFuY2UuJGNoYW5nZXMucm9vdCA9IHRoaXMuJGNoYW5nZXMucm9vdDtcblxuICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfdHJpZ2dlckFsbEZpbGxDaGFuZ2VzKHJlZjogUmVmLCBhbGxDaGFuZ2VzOiBNYXA8bnVtYmVyLCBEYXRhQ2hhbmdlW10+KSB7XG4gICAgICAgIGlmIChhbGxDaGFuZ2VzLmhhcyhyZWZbJyRjaGFuZ2VzJ10ucmVmSWQpKSB7IHJldHVybjsgfVxuXG4gICAgICAgIGNvbnN0IGNoYW5nZXM6IERhdGFDaGFuZ2VbXSA9IFtdO1xuICAgICAgICBhbGxDaGFuZ2VzLnNldChyZWZbJyRjaGFuZ2VzJ10ucmVmSWQgfHwgMCwgY2hhbmdlcyk7XG5cbiAgICAgICAgaWYgKHJlZiBpbnN0YW5jZW9mIFNjaGVtYSkge1xuICAgICAgICAgICAgY29uc3Qgc2NoZW1hID0gcmVmLl9kZWZpbml0aW9uLnNjaGVtYTtcblxuICAgICAgICAgICAgZm9yIChsZXQgZmllbGROYW1lIGluIHNjaGVtYSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IF9maWVsZCA9IGBfJHtmaWVsZE5hbWV9YDtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHJlZltfZmllbGRdO1xuXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wOiBPUEVSQVRJT04uQURELFxuICAgICAgICAgICAgICAgICAgICAgICAgZmllbGQ6IGZpZWxkTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJldmlvdXNWYWx1ZTogdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZVsnJGNoYW5nZXMnXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBTY2hlbWEucHJvdG90eXBlLl90cmlnZ2VyQWxsRmlsbENoYW5nZXMuY2FsbCh0aGlzLCB2YWx1ZSwgYWxsQ2hhbmdlcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgZW50cmllczogSXRlcmFibGVJdGVyYXRvcjxbYW55LCBhbnldPiAgPSByZWYuZW50cmllcygpO1xuICAgICAgICAgICAgbGV0IGl0ZXI6IEl0ZXJhdG9yUmVzdWx0PFthbnksIGFueV0+O1xuXG4gICAgICAgICAgICB3aGlsZSAoKGl0ZXIgPSBlbnRyaWVzLm5leHQoKSkgJiYgIWl0ZXIuZG9uZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IFtrZXksIHZhbHVlXSA9IGl0ZXIudmFsdWU7XG5cbiAgICAgICAgICAgICAgICBjaGFuZ2VzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBvcDogT1BFUkFUSU9OLkFERCxcbiAgICAgICAgICAgICAgICAgICAgZmllbGQ6IGtleSxcbiAgICAgICAgICAgICAgICAgICAgZHluYW1pY0luZGV4OiBrZXksXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgcHJldmlvdXNWYWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlWyckY2hhbmdlcyddICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgU2NoZW1hLnByb3RvdHlwZS5fdHJpZ2dlckFsbEZpbGxDaGFuZ2VzLmNhbGwodGhpcywgdmFsdWUsIGFsbENoYW5nZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgX3RyaWdnZXJDaGFuZ2VzKGFsbENoYW5nZXM6IE1hcDxudW1iZXIsIERhdGFDaGFuZ2VbXT4pIHtcbiAgICAgICAgYWxsQ2hhbmdlcy5mb3JFYWNoKChjaGFuZ2VzLCByZWZJZCkgPT4ge1xuICAgICAgICAgICAgaWYgKGNoYW5nZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlZiA9IHRoaXMuJGNoYW5nZXMucm9vdC5yZWZzLmdldChyZWZJZCk7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNTY2hlbWEgPSByZWYgaW5zdGFuY2VvZiBTY2hlbWE7XG5cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hhbmdlID0gY2hhbmdlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGlzdGVuZXIgPSByZWZbJyRsaXN0ZW5lcnMnXSAmJiByZWZbJyRsaXN0ZW5lcnMnXVtjaGFuZ2UuZmllbGRdO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNTY2hlbWEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaGFuZ2Uub3AgPT09IE9QRVJBVElPTi5BREQgJiYgY2hhbmdlLnByZXZpb3VzVmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChyZWYgYXMgU2NoZW1hRGVjb2RlckNhbGxiYWNrcykub25BZGQ/LihjaGFuZ2UudmFsdWUsIGNoYW5nZS5keW5hbWljSW5kZXggPz8gY2hhbmdlLmZpZWxkKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjaGFuZ2Uub3AgPT09IE9QRVJBVElPTi5ERUxFVEUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZJWE1FOiBgcHJldmlvdXNWYWx1ZWAgc2hvdWxkIGFsd2F5cyBiZSBhdmFpaWFibGUuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQUREICsgREVMRVRFIG9wZXJhdGlvbnMgYXJlIHN0aWxsIGVuY29kaW5nIERFTEVURSBvcGVyYXRpb24uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hhbmdlLnByZXZpb3VzVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAocmVmIGFzIFNjaGVtYURlY29kZXJDYWxsYmFja3MpLm9uUmVtb3ZlPy4oY2hhbmdlLnByZXZpb3VzVmFsdWUsIGNoYW5nZS5keW5hbWljSW5kZXggPz8gY2hhbmdlLmZpZWxkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY2hhbmdlLm9wID09PSBPUEVSQVRJT04uREVMRVRFX0FORF9BREQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hhbmdlLnByZXZpb3VzVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAocmVmIGFzIFNjaGVtYURlY29kZXJDYWxsYmFja3MpLm9uUmVtb3ZlPy4oY2hhbmdlLnByZXZpb3VzVmFsdWUsIGNoYW5nZS5keW5hbWljSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAocmVmIGFzIFNjaGVtYURlY29kZXJDYWxsYmFja3MpLm9uQWRkPy4oY2hhbmdlLnZhbHVlLCBjaGFuZ2UuZHluYW1pY0luZGV4KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2Uub3AgPT09IE9QRVJBVElPTi5SRVBMQUNFIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlLnZhbHVlICE9PSBjaGFuZ2UucHJldmlvdXNWYWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKHJlZiBhcyBTY2hlbWFEZWNvZGVyQ2FsbGJhY2tzKS5vbkNoYW5nZT8uKGNoYW5nZS52YWx1ZSwgY2hhbmdlLmR5bmFtaWNJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAvLyB0cmlnZ2VyIG9uUmVtb3ZlIG9uIGNoaWxkIHN0cnVjdHVyZS5cbiAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgKGNoYW5nZS5vcCAmIE9QRVJBVElPTi5ERUxFVEUpID09PSBPUEVSQVRJT04uREVMRVRFICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2UucHJldmlvdXNWYWx1ZSBpbnN0YW5jZW9mIFNjaGVtYSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlLnByZXZpb3VzVmFsdWUub25SZW1vdmVcbiAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2UucHJldmlvdXNWYWx1ZS5vblJlbW92ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGxpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyLmludm9rZShjaGFuZ2UudmFsdWUsIGNoYW5nZS5wcmV2aW91c1ZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBTY2hlbWEub25FcnJvcihlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChpc1NjaGVtYSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVmLm9uQ2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChyZWYgYXMgU2NoZW1hKS5vbkNoYW5nZShjaGFuZ2VzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBTY2hlbWEub25FcnJvcihlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbiJdfQ==